<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>0xCC0FF - blog</title><link href="https://ccoff.github.io/" rel="alternate"></link><link href="https://ccoff.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://ccoff.github.io/</id><updated>2023-05-14T00:00:00+01:00</updated><subtitle>A companion blog to my GitHub account</subtitle><entry><title>Chasing weather satellites: the sequel</title><link href="https://ccoff.github.io/chasing-weather-satellites-sequel" rel="alternate"></link><published>2023-05-14T00:00:00+01:00</published><updated>2023-05-14T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2023-05-14:/chasing-weather-satellites-sequel</id><summary type="html">&lt;p&gt;This is a follow-up to my previous post about using &lt;a href="https://ccoff.github.io/chasing-weather-satellites-with-sdr"&gt;software-defined radio (SDR) to download real-time data from weather satellites&lt;/a&gt;. I wrapped up that post with "there are several other types of satellite antennas worth exploring -- the double-cross and Moxon turnstile antennas look like they may be an improvement on …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is a follow-up to my previous post about using &lt;a href="https://ccoff.github.io/chasing-weather-satellites-with-sdr"&gt;software-defined radio (SDR) to download real-time data from weather satellites&lt;/a&gt;. I wrapped up that post with "there are several other types of satellite antennas worth exploring -- the double-cross and Moxon turnstile antennas look like they may be an improvement on the basic turnstile."&lt;/p&gt;
&lt;p&gt;Since writing that, I built a prototype Moxon turnstile that performed about as well as the basic turnstile I constructed. I was considering building a quadrifilar helix (QFH) antenna, which is regarded by many as the gold standard for weather satellite reception (and has a great name). But then I came across the &lt;a href="https://www.reddit.com/r/RTLSDR/comments/v07fn9/ive_been_experimenting_with_an_asymmetric/"&gt;asymmetric turnstile antenna (ATA)&lt;/a&gt;, a type I had not heard of before.&lt;/p&gt;
&lt;p&gt;The ATA is a kind of hybrid between a QFH and traditional turnstile. Like a QFH, it has asymmetric lengths for its elements, and is shorted (i.e., the cable's shield is connected to its center conductor). Like a turnstile, the ATA has four straight elements radiating outward and a reflector. It seems to offer the best of both worlds -- the performance of a QFH with simplified construction. (Even easier construction than a traditional turnstile in fact -- there's no phasing harness to worry about with the ATA design).&lt;/p&gt;
&lt;p&gt;According to &lt;a href="https://sgcderek.github.io/tools/ATA.html"&gt;sgcderek's guide&lt;/a&gt;, the ATA is more commonly used at higher frequencies, and relatively unexplored down in VHF where the NOAA satellites transmit APT. Which helps explain why I hadn't heard of it before. In any event, I built a prototype antenna, got it up on the roof, and the results were, in a word, excellent. I started getting usable signal at around 3° elevation, which meant I could capture almost an entire pass, save for 15-30 seconds on either end. Gain was also very good, with SNR levels reaching as high as 55 dB. (In my experience, an SNR of 20 to 25 dB produces usable, but noisy imagery. Anything above 30 dB produces reliably clean, noise-free imagery.)&lt;/p&gt;
&lt;p&gt;I'm in an urban setting with some obstructions on the horizon and a noisy RF environment. But for the high, medium, and low passes shown below, I only used a basic setup (no filters or LNA). The results were impressive:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-2-2023-03-19-08-54-noaa-19-maxel-74.4E.jpg"&gt;&lt;img src="images/wxsat-2-2023-03-19-08-54-noaa-19-maxel-74.4E.jpg" alt="Image: NOAA-19 high pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;High pass (74.4° max elevation): NOAA-19, March 19, 2023 at 07:54 UTC.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/wxsat-2-2023-05-12-09-49-noaa-19-maxel-39.6W.jpg"&gt;&lt;img src="images/wxsat-2-2023-05-12-09-49-noaa-19-maxel-39.6W.jpg" alt="Image: NOAA-19 medium pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Medium pass (39.6° max elevation): NOAA-19, May 12, 2023 at 08:49 UTC.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/wxsat-2-2023-04-14-12-56-noaa-18-maxel-8.7W.jpg"&gt;&lt;img src="images/wxsat-2-2023-04-14-12-56-noaa-18-maxel-8.7W.jpg" alt="Image: NOAA-18 low pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Low pass (8.7° max elevation): NOAA-18, April 14, 2023 at 11:56 UTC.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Over eight minutes of imagery from an 8.7° maximum elevation pass is pretty darn good, and would be unthinkable with my V-dipole or traditional turnstile antenna. Those antennas typically only started capturing usable data at around 20° elevation, or even higher.&lt;/p&gt;
&lt;p&gt;Here is the antenna up on the roof (with my ADS-B and HF antennas visible as well):&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-2-antenna.jpg"&gt;&lt;img src="images/wxsat-2-antenna.jpg" alt="Image: ATA antenna on roof" width="520" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;h2&gt;But wait, there's more&lt;/h2&gt;
&lt;p&gt;The antenna works well for more than just NOAA sats. The &lt;a href="https://en.wikipedia.org/wiki/International_Space_Station"&gt;ISS&lt;/a&gt; has a packet repeater that transmits &lt;a href="https://en.wikipedia.org/wiki/Automatic_Packet_Reporting_System"&gt;APRS&lt;/a&gt; data at around 145 MHz, and the antenna picked it up with ease:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;APRS: IK3ZGB-2&amp;gt;CQ,RS0ISS*:=4542.75N/01142.00E`73&amp;#39; Via ISS de Cris {UISS54}
APRS: 9H1FF&amp;gt;APRS,RS0ISS*::IW6PUA   :msg rcvd tnx
APRS: RS0ISS&amp;gt;0P0PS4,APRSAT:&amp;#39;v&amp;amp;l SI]ARISS-International Space Station=
APRS: OE1WTR&amp;gt;CQ,RS0ISS*,WIDE2-2,QAR::I3JUK    :73&amp;#39; Via Satellite
APRS: 9H1FF&amp;gt;APRS,RS0ISS*:=/&amp;lt;@16R-]&amp;amp;/  B
APRS: IW6PUA&amp;gt;CQ,RS0ISS*::9H1FF    :HELLO, QSL and 73 via ISS
APRS: IW6PUA&amp;gt;CQ,RS0ISS*:=4152.25N/01404.00E-Matteo via ISS
APRS: ON4BN&amp;gt;ALL,RS0ISS*,NA1SS,PSAT:=5103.45N/00522.30Er73&amp;#39; Via Satellite de ON4BN
APRS: 9H1FF&amp;gt;APRS,RS0ISS*:Greetings to all from Malta
APRS: 4Z4DP&amp;gt;SQTQ90,RS0ISS*:&amp;#39;?_Dl `/]73 from Jerusalem=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The antenna also does well with &lt;a href="https://en.wikipedia.org/wiki/Automatic_identification_system"&gt;AIS&lt;/a&gt; transmissions from maritime traffic, which are broadcast at around 162 MHz:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-2-ais-opencpn.png"&gt;&lt;img src="images/wxsat-2-ais-opencpn.png" alt="Image: Displaying AIS ship data on OpenCPN" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;AIS data plotted on a map with the &lt;a href="https://opencpn.org/"&gt;OpenCPN&lt;/a&gt; program.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;All things considered, I'm quite impressed with the ATA's performance, and it will be my "go-to" antenna for NOAA APT reception from now on. It appears to provide comparable performance levels to a QFH, and is easier to build.&lt;/p&gt;
&lt;p&gt;That said, I'm never satisfied. There are some obstructions on the horizon that block the signal; there's not much I can do about that. However, I also see telltale wavy lines in some of the images that are indicators of RF interference, perhaps from power lines. There are &lt;a href="https://www.nooelec.com/store/sawbird-plus-noaa-308.html"&gt;combined LNA/filters&lt;/a&gt; for NOAA sats to help improve reception, but I don't need more gain from an LNA -- this antenna provides plenty of gain. But I would like to see if a 137 MHz bandpass filter cuts down on the RF interference at all. Somewhat surprisingly I haven't found any standalone bandpass filters for that frequency, so I may just try to build one myself.&lt;/p&gt;</content><category term="radio"></category><category term="sdr"></category><category term="satellites"></category></entry><entry><title>Binary patching for fun and zero profit</title><link href="https://ccoff.github.io/binary-patching" rel="alternate"></link><published>2023-03-07T00:00:00+00:00</published><updated>2023-03-07T00:00:00+00:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2023-03-07:/binary-patching</id><summary type="html">&lt;p&gt;I use software-defined radio (SDR) to download &lt;a href="https://ccoff.github.io/chasing-weather-satellites-with-sdr"&gt;real-time data from weather satellites&lt;/a&gt;. To generate the imagery from the data I use the excellent, but no longer maintained, &lt;a href="https://wxtoimgrestored.xyz"&gt;wxtoimg&lt;/a&gt; program on Linux. It generates nice map overlays for the imagery, but to do this correctly, wxtoimg needs up-to-date information on satellite …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I use software-defined radio (SDR) to download &lt;a href="https://ccoff.github.io/chasing-weather-satellites-with-sdr"&gt;real-time data from weather satellites&lt;/a&gt;. To generate the imagery from the data I use the excellent, but no longer maintained, &lt;a href="https://wxtoimgrestored.xyz"&gt;wxtoimg&lt;/a&gt; program on Linux. It generates nice map overlays for the imagery, but to do this correctly, wxtoimg needs up-to-date information on satellite positions. It gets this by downloading the current &lt;a href="https://en.wikipedia.org/wiki/Two-line_element_set"&gt;orbital data&lt;/a&gt; from the internet. Unfortunately wxtoimg uses a hard-coded string for the target hostname, so when the domain changed a few months ago from celestrak.&lt;em&gt;com&lt;/em&gt; to celestrak.&lt;em&gt;org&lt;/em&gt;, wxtoimg couldn't get its satellite positions, and the map overlays were completely wrong.&lt;/p&gt;
&lt;p&gt;wxtoimg is closed-source, so changing the source code and recompiling wasn't an option. I could have written a cron job to fetch the updated satellite data and move it to the configuration folder. But it seemed like it would be easy enough to just patch the program itself to use &lt;em&gt;celestrak.org&lt;/em&gt; instead of &lt;em&gt;celestrak.com&lt;/em&gt; and be done with it, with no need for external workarounds.&lt;/p&gt;
&lt;p&gt;For the uninitiated, you can alter a program's behavior by making relatively small changes direcly to its code (also known as "patching a binary"). Sometimes this is for purely malicious purposes, but in my case, I wanted to fix a bug that otherwise could not be fixed because the source code was not available.&lt;/p&gt;
&lt;h2&gt;Try the easy things first&lt;/h2&gt;
&lt;p&gt;I hoped and assumed that "celestrak.com" was just a string in the &lt;strong&gt;.data&lt;/strong&gt; or &lt;strong&gt;.rodata&lt;/strong&gt; sections of the executable, and therefore easy to modify with a hex editor. But an initial search with the &lt;em&gt;strings&lt;/em&gt; utility didn't turn up anything. So I wrote a short program in C to look for various byte patterns. Again nothing. Next I tried &lt;a href="https://github.com/mandiant/flare-floss"&gt;flare-floss&lt;/a&gt;, which does deep searches of executables for obfuscated strings. Same result-- nothing.&lt;/p&gt;
&lt;p&gt;The string had to be in there somewhere, but where?&lt;/p&gt;
&lt;p&gt;I ran &lt;a href="https://strace.io"&gt;strace&lt;/a&gt; to see what exactly wxtoimg was doing, and sure enough there was an HTTP GET request to celestrak.com (104.168.149.178) to get the satellite data:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;connect(8, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr(&amp;quot;104.168.149.178&amp;quot;)}, 16) = 0
send(8, &amp;quot;GET /NORAD/elements/weather.txt &amp;quot;..., 125, 0) = 125
send(8, &amp;quot;\r\n&amp;quot;, 2, 0)                   = 2
recv(8, &amp;quot;HTTP/1.1 301 Moved Permanently\r\n&amp;quot;..., 4096, 0) = 408
close(8)                                = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As one would expect, a &lt;strong&gt;send()&lt;/strong&gt; call was used to get the satellite data file. It was clear, however, that a simple hex edit replacing "com" with "org" wasn't in the cards. I was going to have to dig deeper and do some &lt;a href="https://en.wikipedia.org/wiki/Static_program_analysis"&gt;static analysis&lt;/a&gt; on the wxtoimg executable.&lt;/p&gt;
&lt;h2&gt;Static analysis&lt;/h2&gt;
&lt;p&gt;Static analysis involves examining the disassembled executable without running it. But first I needed to determine what exactly I was dealing with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;chris@host:~$ file /usr/local/bin/wxtoimg
/usr/local/bin/wxtoimg: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.2.5, stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It was a 32-bit executable. I was happy about that, because at the assembly code level I've worked almost entirely in the 16- and 32-bit space --  64-bit not so much. (Back in the late 90's/early 00's, to put food on the table I worked on 16-bit DOS and 32-bit Linux embedded telecom products.)&lt;/p&gt;
&lt;p&gt;To do static analysis you need a good disassembler, and in my case, one that also ran on Linux and handled &lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;ELF executables&lt;/a&gt;. In the last few years a new player has arrived on the software reverse engineering scene courtesy of the NSA (yes, &lt;em&gt;that&lt;/em&gt; NSA): &lt;a href="https://ghidra-sre.org"&gt;Ghidra&lt;/a&gt;. I had never used Ghidra before, but it looked promising with lots of useful features. And unlike other comparable programs that cost hundreds of dollars, it was free.&lt;/p&gt;
&lt;p&gt;I loaded up wxtoimg in Ghidra, which took a few minutes to disassemble and analyze its code. The Code Browser gave me a list of disassembled functions, a memory map showing the program sections (&lt;strong&gt;.text&lt;/strong&gt;, etc), and other useful goodies.&lt;/p&gt;
&lt;p&gt;Having located the &lt;strong&gt;send()&lt;/strong&gt; function, I worked up the call tree, hoping to find where the "celestrak.com" string came from. I made it up one or two levels, but then the trail stopped. When I looked for references to the next function, Ghidra couldn't find anything. This wasn't too surprising; the disassembler does the best it can to make sense of the raw binary code, but it's not perfect, and some things can only be determined at runtime.&lt;/p&gt;
&lt;p&gt;I had gone as far as I could with static analysis for the moment, so it was time to do some &lt;a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis"&gt;dynamic analysis&lt;/a&gt; and run wxtoimg under a debugger.&lt;/p&gt;
&lt;h2&gt;Unwinding the stack&lt;/h2&gt;
&lt;p&gt;A brief detour down memory lane: from my software development days, I remember using a program from Microsoft called Codeview. It had a text console split into several windows that allowed you to view a program's memory and registers in real-time while stepping through instructions. It was invaluable for seeing how the stack and memory management worked at a low level.&lt;/p&gt;
&lt;p&gt;What really gave me deeper knowledge of the stack, however, was the excellent article &lt;a href="https://www.eecs.umich.edu/courses/eecs588/static/stack_smashing.pdf"&gt;"Smashing the stack for fun and profit"&lt;/a&gt;, which first appeared in 1996. The intended audience was those looking to spawn shell code from within a vulnerable executable. Namely, by overwriting parts of the stack via buffer overflow exploits (AKA "smashing the stack"). But the same principles of stack layouts used in cracking applied equally to reverse engineering and non-malicious binary patching.&lt;/p&gt;
&lt;p&gt;Fast forward to the present. In Ghidra I set a breakpoint on &lt;strong&gt;send()&lt;/strong&gt;, started wxtoimg, and selected the option to update the satellite data. The debugger (Ghidra uses &lt;a href="https://www.sourceware.org/gdb"&gt;gdb&lt;/a&gt; under the hood) stopped and now I had the call stack backtrace.&lt;/p&gt;
&lt;p&gt;I hadn't examined a stack at byte level in about 20 years and was rusty. Dredging up my stack-smashing knowledge from days of yore, I looked at the &lt;strong&gt;EBP&lt;/strong&gt; register to get the base pointer. Then I went to that address in Ghidra's memory viewer to get to the entry point of the &lt;strong&gt;send()&lt;/strong&gt; call. The &lt;a href="https://linux.die.net/man/2/send"&gt;&lt;strong&gt;send()&lt;/strong&gt; function&lt;/a&gt; has the following call signature:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;ssize_t&lt;/span&gt; &lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb nb-Type"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The second parameter (*&lt;em&gt;buf&lt;/em&gt;) contains the data to send, and this is what I was interested in. On the 32-bit x86 architecture, the calling convention places function parameters on the stack as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Towards&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;addresses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="o"&gt;.&lt;/span&gt;
       &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;:::&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
     &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;:::::::&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
       &lt;span class="p"&gt;:::::&lt;/span&gt;
       &lt;span class="p"&gt;:::::&lt;/span&gt;

&lt;span class="n"&gt;Additional&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Local&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Return&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Parameter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Parameter&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Parameter&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;---------------------------------&lt;/span&gt;
&lt;span class="n"&gt;Additional&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

       &lt;span class="p"&gt;:::::&lt;/span&gt;
       &lt;span class="p"&gt;:::::&lt;/span&gt;
     &lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;:::::&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;
      &lt;span class="s1"&gt;&amp;#39;:::::&amp;#39;&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;:&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;Towards&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;higher&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;addresses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So by adding 12 bytes to &lt;strong&gt;EBP&lt;/strong&gt;, I had the address to the second parameter *&lt;em&gt;buf&lt;/em&gt;. And that contained the HTTP GET request for the satellite data, confirming I was in the right place.&lt;/p&gt;
&lt;p&gt;I moved up the call stack from &lt;strong&gt;send()&lt;/strong&gt;, eventually landing in a bunch of &lt;a href="https://en.wikipedia.org/wiki/Tcl"&gt;Tcl&lt;/a&gt; networking function calls. I was vaguely aware of Tcl but had never programmed in it. Wikipedia said Tcl was commonly "embedded into C applications, for rapid prototyping, scripted applications, GUIs, and testing." And that appeared to be the case here with wxtoimg -- it was an executable stuffed with embedded Tcl scripts and Tcl library code.&lt;/p&gt;
&lt;p&gt;But that gave me an idea -- I downloaded the Tcl source code and found that some strings in wxtoimg were in Tcl functions. By searching for strings in wxtoimg that were also in the Tcl source, I could correlate sections of wxtoimg's disassembled code with Tcl library functions. This was a huge help in determining what some of these functions were doing.&lt;/p&gt;
&lt;p&gt;I continued working through the call stack, but started getting lost in a maze of function calls trying to determine where "celestrak.com" came from. It seemed that the embedded Tcl script files were obfuscated in the executable at rest and loaded on the fly. As I continued to work through the function calls it occurred to me that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Even when I found the script, I may not be able to reverse-engineer the obfuscation algorithm to patch it correctly.&lt;/li&gt;
&lt;li&gt;Even if I patched that particular script in the executable, what if another script somewhere else in the program used a hard-coded "celestrak.com" string? I'd have to repeat the process all over again.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I decided it was easier to intercept the "celestrak.com" hostname string later in the call stack, closer to where it was actually used to open a network connection. In other words, instead of patching an embedded, obfuscated Tcl script in the executable, I would patch the embedded Tcl network library code itself to use the correct hostname.&lt;/p&gt;
&lt;h2&gt;Making the patch&lt;/h2&gt;
&lt;p&gt;Patching a binary is not a simple thing. Pitfalls are everywhere: one wrong bit or byte, a miscalculation in a jump, or any other number of slip-ups, and the program will at a minimum exhibit unexpected behavior, or more likely, segfault and crash.&lt;/p&gt;
&lt;p&gt;At a macro level, all I wanted to do was look at the hostname string used to open a connection, and if it matched "celestrak.com" replace it with "celestrak.org". But there were some complications. I wanted my patch to be in complete control of the registers, and also avoid using any local variables. That meant avoiding function calls to library routines like &lt;strong&gt;strcmp()&lt;/strong&gt; and &lt;strong&gt;strcpy()&lt;/strong&gt;, and using instead a self-contained block of code that did the string manipulations with no "outside" interference.&lt;/p&gt;
&lt;p&gt;I wrote up the patch code in C, compiled it, and then used &lt;a href="https://en.wikipedia.org/wiki/Objdump"&gt;objdump&lt;/a&gt; to disassemble it. For example, here's the portion of the patch that copies the correct string to the hostname (because of my DOS days, I "think" in Intel assembly syntax instead of AT&amp;amp;T syntax, so that's what appears below):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;lea&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebx-0x3d5a30&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;b9&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x12&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="nl"&gt;d&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;cld&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="nl"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a4&lt;/span&gt;&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="n"&gt;rep&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;movs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BYTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PTR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;es&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;BYTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PTR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;esi&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This gave me a starting point to work from for the assembly code and associated opcodes that would become the patch. But there was still a lot of work to do, not the least of which was determining &lt;em&gt;where&lt;/em&gt; to place the patch in the executable. My patch (i.e., the sequence of raw opcodes) worked out to 81 bytes in total. I needed to find that much unused space -- also known as a &lt;a href="https://en.wikipedia.org/wiki/Code_cave"&gt;code cave&lt;/a&gt; -- in the executable.&lt;/p&gt;
&lt;p&gt;I used the &lt;a href="https://github.com/guitmz/gocave"&gt;gocave&lt;/a&gt; program, which just looks for sequences of repeating null bytes in an executable. The largest cave it found in the &lt;strong&gt;.text&lt;/strong&gt; section was 7 bytes -- nowhere near large enough to hold my patch. The &lt;strong&gt;.data&lt;/strong&gt; and &lt;strong&gt;.rodata&lt;/strong&gt; sections, on the other hand, had large caves, but the sections weren't marked as executable. I didn't really want to mess with the executable's section headers, whether by changing read/write/execute permissions, expanding an existing section, or creating an entirely new one. I was out of luck, or so it seemed...&lt;/p&gt;
&lt;p&gt;As mentioned above, I was able to correlate some code sections with Tcl library functions. One of those functions was &lt;a href="https://core.tcl-lang.org/tcl/file?name=generic/tclIOCmd.c"&gt;&lt;strong&gt;Tcl_SocketObjCmd()&lt;/strong&gt;&lt;/a&gt;, which opened a client socket to the specified hostname. But the function also contained several code blocks for server sockets, for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;AcceptCallback&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;acceptCallbackPtr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AcceptCallback&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Tcl_Alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AcceptCallback&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;Tcl_IncrRefCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;script&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;acceptCallbackPtr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;script&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;script&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;acceptCallbackPtr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;interp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;interp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;chan&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Tcl_OpenTcpServerEx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;host&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backlog&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;AcceptCallbackProc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acceptCallbackPtr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Server-specific code continues for several more lines... */&lt;/span&gt;
  &lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Client code here -- MUST NOT TOUCH! */&lt;/span&gt;
  &lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;wxtoimg was just a TCP client though, so those blocks of server code were unused and taking up space -- space I could put to good use. That particular server code block above occupied 201 bytes, which was more than enough room for my 81-byte patch. And crucially, one of the parameters for the &lt;strong&gt;Tcl_SocketObjCmd()&lt;/strong&gt; function was the target hostname ("celestrak.com").&lt;/p&gt;
&lt;p&gt;So I had my binary patch code, and somewhere to put it. Still, I couldn't just drop the bytecode into the executable; doing so would surely cause it to blow up in spectacular fashion. Instead I had to do some careful hand-tweaking so it played nicely with the rest of the executable. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jump offset values: These had to be manually calculated to make sure jumps went to the right code locations.&lt;/li&gt;
&lt;li&gt;Stack/register maintenance: Any registers or flags that the patch code changed had to be saved in advance and later restored. This ensured that the existing code had no idea my patch was ever there.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If this sounds like a laborious process, you're right. There's a reason we use compilers to do this dirty work for us whenever possible.&lt;/p&gt;
&lt;p&gt;I made the necessary adjustments, copied the bytecode into the executable, and was finally ready to run the patched wxtoimg. Did it work? Of course not. Code never works perfectly the first time through, at least not mine. Especially when working with raw bytecode. When I went to the option in wxtoimg to update the satellite data, the program hung.&lt;/p&gt;
&lt;p&gt;When I added my patch code, I had overwritten all of the remaining unused server code with &lt;a href="https://en.wikipedia.org/wiki/NOP_(code)"&gt;NOPs&lt;/a&gt;. But some of what was seemingly unused server code was in fact referenced by binary code branches elsewhere, effectively leaving "hanging" branches that went to nowhere. I didn't know for sure, but I was guessing that even though the program was not actually executing those hanging branches, the CPU was still following them due to &lt;a href="https://en.wikipedia.org/wiki/Branch_predictor"&gt;predictive execution&lt;/a&gt;. Because I had invalidated some of those paths with NOPs, the program hung.&lt;/p&gt;
&lt;p&gt;I may be totally wrong about this; I'm not an expert in CPU design. What I do know is that I scaled back my NOP padding, retaining the server code that was referenced by another branch (luckily there was still plenty of space for my patch). And this time -- it worked! My patch stepped in anytime a socket to celestrak.com was requested, and opened it at celestrak.org instead:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/binary-patching-memory-string-patch-success.png"&gt;&lt;img src="images/binary-patching-memory-string-patch-success.png" alt="Image: View of memory with patched string" /&gt;&lt;/a&gt;
&lt;figcaption&gt;A view of memory, just after the patch makes the final alteration to the hostname string.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Further testing confirmed that my binary patch was working as intended, with no apparent adverse effects.&lt;/p&gt;
&lt;p&gt;In the end, it was a lot of work to change those three letters in the hostname from "com" to "org". But it's not the destination, it's the journey right? And now every time I run my patched wxtoimg and watch it update the satellite data, I have to admit I get a small buzz.&lt;/p&gt;</content><category term="sdr"></category><category term="satellites"></category><category term="linux"></category><category term="reverse engineer"></category></entry><entry><title>Not your father's radio: listening to shortwave with software-defined radio</title><link href="https://ccoff.github.io/listening-to-shortwave-with-sdr" rel="alternate"></link><published>2022-10-04T00:00:00+01:00</published><updated>2022-10-04T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2022-10-04:/listening-to-shortwave-with-sdr</id><summary type="html">&lt;p&gt;Many years ago, I used my father's radio every now and then to listen to the shortwave bands. I would slowly turn the dials, hunting around for something to listen to. When I landed on something audible and semi-intelligible, I'd try to figure out what language I was hearing and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Many years ago, I used my father's radio every now and then to listen to the shortwave bands. I would slowly turn the dials, hunting around for something to listen to. When I landed on something audible and semi-intelligible, I'd try to figure out what language I was hearing and where the transmission might be coming from.&lt;/p&gt;
&lt;p&gt;The radio was a big, analog set -- specifically, an &lt;a href="https://www.radiomuseum.org/r/ross_world_master_re_8000.html"&gt;"RE-8000"&lt;/a&gt; made by &lt;a href="https://www.radiomuseum.org/dsp_hersteller_detail.cfm?company_id=3298"&gt;Ross Electronics Company&lt;/a&gt;:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/shortwave-radio-front.jpg"&gt;&lt;img src="images/shortwave-radio-front.jpg" alt="Image: RE-8000 radio - front view" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;All those dials and pushbuttons... This radio still works, by the way.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/shortwave-radio-backplate.jpg"&gt;&lt;img src="images/shortwave-radio-backplate.jpg" alt="Image: RE-8000 radio - backplate" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Backplate with frequency ranges.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;!--
https://radioattic.com/item.htm?radio=0270328
--&gt;

&lt;p&gt;Looking back, there's a certain nostalgic appeal to twisting the dials and slowly working my way across the bands. But technology moves on, and there are more efficient (and I would argue, enjoyable) ways now to pull those faraway transmissions out of the air -- namely, SDR (software-defined radio).&lt;/p&gt;
&lt;h2&gt;The receiver&lt;/h2&gt;
&lt;p&gt;Software-defined radio opens up a world of possibilities. As I've mentioned in other posts, I have received &lt;a href="https://ccoff.github.io/chasing-weather-satellites-with-sdr"&gt;satellite&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Automatic_Dependent_Surveillance%E2%80%93Broadcast"&gt;aircraft&lt;/a&gt; transmissions, worked with &lt;a href="https://ccoff.github.io/temperature-sensor-sdr-radio"&gt;temperature sensors&lt;/a&gt;, and more.&lt;/p&gt;
&lt;p&gt;My main SDR workhorse is the &lt;a href="https://www.rtl-sdr.com"&gt;rtl-sdr&lt;/a&gt;. Costing only $25, it covers a wide frequency range, 24 MHz to 1.7 GHz. But for shortwave, we need to go lower than 24 MHz. Although the rtl-sdr can do this via direct sampling, it didn't work well in my experience, and in any event, I wanted an SDR designed "from the ground up" to cover the lower frequencies down in the HF range. Enter the &lt;a href="https://www.sdrplay.com/rsp1a"&gt;SDRPlay RSP1a&lt;/a&gt;: for about $110, this SDR goes from 1 kHz (!) all the way up to 2 GHz. It also has a much wider visible bandwidth than the rtl-sdr (you can see up to 10 MHz of spectrum simultaneously), built-in filters, a higher-resolution &lt;a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter"&gt;ADC&lt;/a&gt;, and more.&lt;/p&gt;
&lt;p&gt;But a receiver by itself is pretty useless -- you also need a decent antenna.&lt;/p&gt;
&lt;h2&gt;The antenna&lt;/h2&gt;
&lt;p&gt;Unlike an antenna for ADS-B or NOAA satellites that is optimized to a specific frequency, for shortwave/HF we need to cover a wide frequency range -- about 500 kHz (AM radio) up to at least 18 MHz or more. Additionally, with frequencies much lower than VHF/UHF, we need a longer antenna. (The higher the frequency, the shorter the antenna. The lower the frequency, the longer the antenna.)&lt;/p&gt;
&lt;p&gt;I had a 100-foot spool of 16 AWG speaker wire, so a &lt;a href="https://en.wikipedia.org/wiki/Random_wire_antenna"&gt;random wire antenna&lt;/a&gt; seemed like a good option to try. As its name implies, it's just a random length of wire that functions as an antenna. It doesn't really get more basic than that, but as with most antennas, the important thing is to try and get it as high as possible. Luckily I had access to the roof:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/shortwave-antenna.jpg"&gt;&lt;img src="images/shortwave-antenna.jpg" alt="Image: Random wire antenna" width="520" height="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Random wire antenna on the roof (indicated by red arrows). Also visible between the arrows is my &lt;a href="http://www.radioforeveryone.com/p/coketenna-easy-cheap-effec.html"&gt;"Coketenna"&lt;/a&gt; for tracking airplanes.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I ran the wire around most of the roof, down the outside wall and into my office, where I connected it to a &lt;a href="https://www.nooelec.com/store/balun-one-nine-v2.html"&gt;9:1 balun&lt;/a&gt;. The other balun connection went to ground -- specifically, a wire to the radiator pipe. A ground connection wasn't strictly necessary, but I found that it improved reception on most bands. During my testing, connecting and disconnecting the ground wire from the balun got tiresome, so I wired up a switch to quickly engage or disengage it:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/shortwave-balun.jpg"&gt;&lt;img src="images/shortwave-balun.jpg" alt="Image: Balun connections" width="520" height="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;The antenna wire and ground wire (with cut-off switch) connect to the balun, which connects to the SDR, which connects to the computer.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2&gt;What's the frequency, Kenneth?&lt;/h2&gt;
&lt;p&gt;It was time to see what I could receive.&lt;/p&gt;
&lt;p&gt;I usually use &lt;a href="https://gqrx.dk"&gt;Gqrx&lt;/a&gt; as my SDR application, but &lt;a href="https://cubicsdr.com"&gt;CubicSDR&lt;/a&gt; worked better with the SDRPlay. In any event, like most SDR applications, it shows a slice of the radio spectrum in a "waterfall" display, making it easy to pick out active signals:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/shortwave-waterfall.gif"&gt;&lt;img src="images/shortwave-waterfall.gif" alt="Image: Waterfall display" width="520" height="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Waterfall of the 31m (9.4-9.9 MHz) SW band.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Unlike with the old analog shortwave radio, there was no need to slowly turn the dial searching for active stations. Here I could see at a glance what was broadcasting, and on exactly which frequency.&lt;/p&gt;
&lt;p&gt;Also in contrast to that bygone era, now there was a wealth of online resources with information that I could only have dreamed of having way back when. The SDR's frequency precision, combined with the information on &lt;a href="https://www.short-wave.info/index.php"&gt;this site&lt;/a&gt;, made it trivial to figure out at any given moment what station I was listening to, its transmitter strength in kilowatts, and where it was located. No more guesswork!&lt;/p&gt;
&lt;p&gt;Here are some of the stations I received from my location in North Africa:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BBC from Ascension Island (~3,500 miles away)&lt;/li&gt;
&lt;li&gt;China Radio International from Jinhua, China (~6,000 miles away)&lt;/li&gt;
&lt;li&gt;Radio Free Asia from Agingan Point, Northern Mariana Islands (~7,800 miles away)&lt;/li&gt;
&lt;li&gt;VOA from Kuwait (~2,200 miles away)&lt;/li&gt;
&lt;li&gt;Voice of Korea from Kujang, North Korea (~5,700 miles away)&lt;/li&gt;
&lt;li&gt;TWR Africa from Manzini, Swaziland (~4,600 miles away)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not bad for a random length of wire on the roof!&lt;/p&gt;</content><category term="radio"></category><category term="sdr"></category><category term="shortwave"></category></entry><entry><title>Chasing weather satellites with software-defined radio</title><link href="https://ccoff.github.io/chasing-weather-satellites-with-sdr" rel="alternate"></link><published>2021-06-02T00:00:00+01:00</published><updated>2021-06-02T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2021-06-02:/chasing-weather-satellites-with-sdr</id><summary type="html">&lt;p&gt;No matter where you are on Earth, several weather satellites pass overhead at least twice a day, broadcasting real-time imagery of what they see below. The most well-known of these satellites, at least in amateur radio circles, are the American NOAA and Russian Meteor satellites.&lt;/p&gt;
&lt;p&gt;The NOAA satellites (there are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;No matter where you are on Earth, several weather satellites pass overhead at least twice a day, broadcasting real-time imagery of what they see below. The most well-known of these satellites, at least in amateur radio circles, are the American NOAA and Russian Meteor satellites.&lt;/p&gt;
&lt;p&gt;The NOAA satellites (there are currently three of them, NOAA-15, -18, and -19) broadcast at around 137 MHz in the analog &lt;a href="https://en.wikipedia.org/wiki/Automatic_picture_transmission"&gt;Automatic Picture Transmission (APT)&lt;/a&gt; format. (They also broadcast digital formats at a much higher frequency, but that requires a high-gain antenna with a way to track the satellite as it passes over, significantly complicating the task.) The Russian Meteor-M 2 satellite also broadcasts around 137 MHz, but in the digital &lt;a href="https://en.wikipedia.org/wiki/Low-rate_picture_transmission"&gt;low-rate picture transmission (LRPT)&lt;/a&gt; format. By way of comparison, digital LRPT has a resolution of 1 km/pixel, while analog APT is 4km/pixel.&lt;/p&gt;
&lt;p&gt;In the not-too-distant past, you needed dedicated, expensive hardware to receive these transmissions. But with software-defined radio (SDR), the entry barriers to obtaining real-time weather satellite imagery are much lower. You can get a basic SDR dongle for $10, and construct a simple antenna for even less.&lt;/p&gt;
&lt;p&gt;As I mentioned in a &lt;a href="https://ccoff.github.io/temperature-sensor-sdr-radio"&gt;previous post&lt;/a&gt;, I've been a fan of SDR for some time. I've picked up pager and GSM traffic, ADS-B transmissions from aircraft, devices in the &lt;a href="https://en.wikipedia.org/wiki/ISM_radio_band"&gt;ISM band&lt;/a&gt;, and more. Getting imagery from weather satellites had been on my "to-do" list for some time, and it just so happened that I now had a high, partially flat roof with a mostly unobstructed view of the horizon, except for some trees to the north.&lt;/p&gt;
&lt;h2&gt;Bird is the word&lt;/h2&gt;
&lt;p&gt;First though, I needed an antenna suitable for receiving satellite transmissions. The popular &lt;a href="https://lna4all.blogspot.com/2017/02/diy-137-mhz-wx-sat-v-dipole-antenna.html"&gt;V-dipole&lt;/a&gt; is easy to make, and looked like a good proof-of-concept. Before I built one though, I fished out an old TV "rabbit ears" antenna I had laying around, and as specified in the V-dipole plans, bent the elements to a 120 degree angle and extended them out to 54 cm to receive at 137 MHz.&lt;/p&gt;
&lt;p&gt;I used the &lt;a href="https://github.com/rt-bishop/Look4Sat"&gt;Look4Sat app&lt;/a&gt; to determine when a satellite would pass over my location. I hooked up the antenna to the SDR dongle, and listened in using the SDR receiver software &lt;a href="https://gqrx.dk"&gt;Gqrx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Despite hanging the antenna out on a window ledge, which was not ideal (you want the antenna up higher with a clear view of the sky) I was able to hear faint beeps of the NOAA "bird" as it went over. The signal was not nearly strong enough to get any imagery or useful data, but it was something, and all the encouragement I needed to press ahead.&lt;/p&gt;
&lt;h2&gt;The V-dipole antenna&lt;/h2&gt;
&lt;p&gt;I set about building a dedicated V-dipole antenna. Again, construction of this antenna is simple. I took two telescoping antennas (purchased from &lt;a href="https://www.aliexpress.com/item/32583918911.html"&gt;AliExpress&lt;/a&gt;) and mounted them on a block of wood with 120 degrees of separation. Then I took an RG-6 coax cable, ran the core to one of the antennas, and the shield to the other, using a terminal block to connect everything. I mounted the entire contraption on a pole (in this case a mop handle), extended the elements out to 54 cm, and it was ready to go:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-v-dipole-antenna.jpg"&gt;&lt;img src="images/wxsat-v-dipole-antenna.jpg" alt="Image: V-dipole antenna" width="520" height="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;V-dipole antenna. The unused plastic ties on top are from an earlier experiment.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I went up on the roof, and after some trial and error with Gqrx settings, I received my first usable transmission. I ran the &lt;em&gt;wav&lt;/em&gt; file through an APT decoder, and got my first, grainy image:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-v-dipole-first-pass.png"&gt;&lt;img src="images/wxsat-v-dipole-first-pass.png" alt="Image: First pass from V-dipole antenna" width="520" height="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;First success with the V-dipole antenna. Spain is almost entirely covered by clouds. Click the image to enlarge, and if you look closely you can see the outlines of the north coast of Africa, the south coast of France, Sardinia, and Corsica.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Okay, there was a lot of noise, and it was hard to pick out landmasses (this was a night pass), but there were definitely clouds visible there. Over the next several days, I caught more passes, with varying levels of success. With the V-dipole I could get some imagery, but there were significant limitations. There were "nulls" or dead zones where the signal dropped out. And the antenna needed fairly high elevation passes to get usable imagery. (Passes are measured in degrees, with 0 degrees at the horizon, and 90 degrees directly overhead. The quality and type of antenna, among other factors, helps determine the minimum pass elevation that yields useful data.)&lt;/p&gt;
&lt;p&gt;The V-dipole was a good first antenna for experimenting, but I would have to build something else to get higher-quality images.&lt;/p&gt;
&lt;h2&gt;Enter the turnstile&lt;/h2&gt;
&lt;p&gt;There were several possibilities for satellite antennas, but the &lt;a href="http://dodgem37.com/wp-content/uploads/2019/04/How-To-Build-A-QFH.pdf"&gt;quadrifilar helix (QFH)&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Turnstile_antenna"&gt;turnstile&lt;/a&gt; appeared to be the most popular. The turnstile looked easier to construct given the limited materials I had at hand, so I decided to go with that. &lt;/p&gt;
&lt;p&gt;There are several plans online for turnstile antennas, but I chose &lt;a href="http://www.radioamatoripeligni.it/i6ibe/pdf/noaa897.pdf"&gt;this one from an Italian amateur radio enthusiast&lt;/a&gt; (see page 8 of the PDF).&lt;/p&gt;
&lt;p&gt;I didn't want to just build the antenna blindly though -- I wanted to have an idea of where the lengths for the dipoles, cables, and so on came from. I'm no RF engineer, so I went down the rabbit hole a bit to get the answers, but it was a good learning experience.&lt;/p&gt;
&lt;details&gt;&lt;summary&gt;Details: Click here for a side discussion into physics and measurements&lt;/summary&gt;
&lt;br/&gt;
In the schematic, the total dipole length is 109 cm, with each element 54 cm. (Note that this matches the 54 cm used in the V-dipole antenna.) The speed of light in a vacuum is around 300,000 km/second, or 300,000,000 meters/second. The weather satellites broadcast from around 137.1 MHz to 137.9 MHz, so we choose the middle value of 137.5 MHz, or 137,500,000 Hz (cycles per second). To get the wavelength for 137.5 MHz, we divide the speed of light by the frequency. In other words, dropping the extra zeros, 3000 divided by 1375, which gives us a 2.18 meter wavelength. For a half-wavelength dipole, divide 2.18 by 2, which equals 1.09 meters, or 109 cm. A 1 cm gap between the two elements of the dipole leaves us with two 54 cm segments as specified in the plans. Why a half-wavelength dipole, you may ask? It all comes down to "catching the wave" and here I defer to &lt;a href="https://en.wikipedia.org/wiki/Dipole_antenna"&gt;Wikipedia&lt;/a&gt;, which has some nice animations.
&lt;br/&gt;
&lt;br/&gt;
Moving on to the reflector elements, I read in several places that the reflectors should be around 5% longer than the driven dipoles. (I have yet to see an explanation for why 5% is the magic number, however.) In any event, taking the dipole length of 109 cm and adding 5% we get 114.45 cm, or the 114 cm shown in the schematic. So far, so good. As for the distance between the dipoles on top and the reflectors below, some sources said "a little less than a quarter-wavelength distance." Again, I have yet to see a formula or explanation for this. But the 46 cm specified is indeed "a little less" (about 15% less) than a quarter-wavelength, so I would just have to go on faith there.
&lt;br/&gt;
&lt;br/&gt;
With the dipole and reflector calculations mostly demystified, there was the matter of phase and polarization. A weather satellite's orientation in space is constantly changing through rotation, so it uses a &lt;a href="https://en.wikipedia.org/wiki/Circular_polarization"&gt;circularly polarized&lt;/a&gt; signal to counteract this. To get a circularly polarized antenna, the coax core and shield must connect to specific dipole elements, and the two dipoles must be out of phase with each other by 90 degrees (or a quarter-wavelength, as 90/360 = 1/4). In theory, this means that the coax to one of the dipoles should be 1/4-wavelength longer than the coax to the other dipole. In practice, though, RF energy travels slower in coax cable than in a vacuum, and this value is expressed as the &lt;a href="https://en.wikipedia.org/wiki/Velocity_factor"&gt;velocity factor&lt;/a&gt;. The RG-58 cable I was using had a velocity factor of 0.66. So 1/4-wavelength, or 54 cm, multiplied by 0.66 gives us 35.64 cm, which is close to the difference between the 35 cm and 72 cm cable sections shown in the schematic.
&lt;br/&gt;
&lt;br/&gt;
The final bit was the matching section of 75 ohm coax to get the impedance to around 50 ohms. Mismatched impedances means less signal reaching the receiver, which we obviously do not want. The &lt;a href="http://www.antentop.org/w4rnl.001/quarter.html"&gt;quarter-wavelength coax matching section&lt;/a&gt; appears to be the most commonly used technique to match impedances. The 75 ohm RG-59 cable I was using had a velocity factor of 0.78, so 54 cm multiplied by 0.78 gives us 42 cm, which is close to the 43 cm shown in the schematic. So that checked out as well.
&lt;br/&gt;
&lt;br/&gt;
Still with me? Let's return to the main tale...
&lt;br/&gt;
&lt;br/&gt;
&lt;/details&gt;
&lt;p&gt;&lt;br/&gt;
I used a bunch of telescopic antennas (eight total) for the dipoles and reflectors. Terminal blocks came in handy again for connecting everything up. With a wooden broom handle to support everything, I had my first prototype turnstile antenna. I went up on the roof and set everything up:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-turnstile-antenna.jpg"&gt;&lt;img src="images/wxsat-turnstile-antenna.jpg" alt="Image: Turnstile antenna prototype" width="500" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Behold the turnstile antenna.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/wxsat-turnstile-antenna-closeup.jpg"&gt;&lt;img src="images/wxsat-turnstile-antenna-closeup.jpg" alt="Image: Turnstile antenna closeup" width="500" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Closeup of the top of the turnstile antenna.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;As the satellite came over the horizon, faint lines appeared in the spectrum waterfall in Gqrx. The signal faded in and out below about 20 degrees, which was expected -- a turnstile designed for satellite reception has a &lt;a href="https://en.wikipedia.org/wiki/Radiation_pattern"&gt;radiation pattern&lt;/a&gt; that is weak towards the horizon, and stronger overhead. (The national broadcaster's huge FM transmitters about 2 miles directly to the south of my location may have interfered as well.) By about 25 degrees elevation, a decent signal was coming through. When you hear the 'tick-tock' in between the high-pitched tones, you know you're getting a good, strong signal. Here's an audio clip from one of my captures:&lt;/p&gt;
&lt;p&gt;&lt;a href="audio/wxsat-noaa-sample.mp3"&gt;Audio sample from NOAA satellite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The signal maintained its strength as the bird went overhead, with virtually no interference or noise. This was in contrast to the V-dipole, which would sometimes drop out when a satellite was high overhead.&lt;/p&gt;
&lt;p&gt;I caught some more passes, adding an &lt;a href="https://en.wikipedia.org/wiki/Low-noise_amplifier"&gt;LNA (low-noise amplifier)&lt;/a&gt; into the mix to boost the signal. After processing the captured signals with the excellent &lt;a href="https://wxtoimgrestored.xyz/"&gt;WXtoImg&lt;/a&gt; program I had some nice images from the NOAA birds:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-noaa-15-2021-05-08.jpg"&gt;&lt;img src="images/wxsat-noaa-15-2021-05-08.jpg" alt="Image: NOAA-15 satellite pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;NOAA-15 pass, May 8, 2021 at 07:50 UTC, maximum elevation 60 degrees. The gray in the Mediterranean is sunlight reflecting back at the satellite. Click the image for the full-resolution picture.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/wxsat-noaa-19-2021-05-08.jpg"&gt;&lt;img src="images/wxsat-noaa-19-2021-05-08.jpg" alt="Image: NOAA-19 satellite pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;NOAA-19 pass, May 8, 2021 at 08:08 UTC, maximum elevation 40 degrees. Note the storm heading towards Ireland. Click the image for the full-resolution picture.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;WXtoImg has numerous imagery enhancements to choose from -- this is a pass with the thermal filter applied:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-noaa-18-2021-05-27.jpg"&gt;&lt;img src="images/wxsat-noaa-18-2021-05-27.jpg" alt="Image: NOAA-18 satellite pass" width="520" /&gt;&lt;/a&gt;
&lt;figcaption&gt;NOAA-18 pass, May 27, 2021 at 10:25 UTC, maximum elevation 75 degrees. Blue represents cold temperatures, red represents hot temperatures. Click the image for the full-resolution picture.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;As I mentioned above, the Russian Meteor satellite transmits a digital signal, so it is less forgiving. Any interference or dropouts results in lost data and stark lines in the image. Still, the much higher resolution as compared to the NOAA APT imagery makes up for it:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/wxsat-meteor-2021-05-08.png"&gt;&lt;img src="images/wxsat-meteor-2021-05-08.png" alt="Image: Meteor satellite pass #1" width="600" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Meteor pass, May 8, 2021 at 07:33 UTC, showing southern Europe and north Africa. Note the sunlight reflecting off of the eastern Mediterranean. The dark spot on the eastern part of Sicily is Mount Etna. Click the image for the full-resolution picture.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/wxsat-meteor-2021-06-01.png"&gt;&lt;img src="images/wxsat-meteor-2021-06-01.png" alt="Image: Meteor satellite pass #2" width="600" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Meteor pass, June 1, 2021 at 19:17 UTC, showing sunset over the Iberian peninsula and northwest Africa. Click the image for the full-resolution picture.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2&gt;Next steps&lt;/h2&gt;
&lt;p&gt;I'm pleased with the turnstile's performance, especially as I'm flying blind with regards to its RF characteristics, such as frequency resonance, phase, and &lt;a href="https://en.wikipedia.org/wiki/Standing_wave_ratio"&gt;SWR&lt;/a&gt; (standing wave ratio, a measurement of impedance mismatches). I think the next step is to get a &lt;a href="https://en.wikipedia.org/wiki/Network_analyzer_(electrical)"&gt;vector network analyzer (VNA)&lt;/a&gt; like &lt;a href="http://nanovna.com"&gt;this one&lt;/a&gt; to measure how closely the antenna's real-world performance matches the theoretical calculations.&lt;/p&gt;
&lt;p&gt;Another priority is to weather-proof the antenna and run a cable to inside the house. Then I can chase satellites from the comfort of my desk, without having to go up on the roof every time I want to catch a pass. &lt;/p&gt;
&lt;p&gt;Beyond that, there are several other types of satellite antennas worth exploring -- the &lt;a href="https://www.qsl.net/l/lu7did/docs/NOAA/DoubleCross_137Mhz%20AntennaMARTES.pdf"&gt;double-cross&lt;/a&gt; and &lt;a href="http://www.oocities.org/w9bci/VHFUHFSatelite.pdf"&gt;Moxon turnstile&lt;/a&gt; antennas look like they may be an improvement on the basic turnstile. &lt;/p&gt;
&lt;p&gt;In addition to the NOAA and Meteor polar-orbiting satellites, there are also weather satellites parked in geostationary orbit. Their signals are much weaker, but on the other hand, the satellites don't move relative to your position. You need a fixed parabolic dish to receive these signals, along with a custom feedhorn, such as a &lt;a href="https://en.wikipedia.org/wiki/Cantenna"&gt;cantenna&lt;/a&gt;. Because these satellites are much farther away than the polar-orbiting birds in low Earth orbit, their imagery shows the &lt;a href="https://www.star.nesdis.noaa.gov/GOES/fulldisk_band.php?sat=G17&amp;amp;band=GEOCOLOR&amp;amp;length=12"&gt;full disk of Earth&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So many satellites, so little time...&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;UPDATE&lt;/strong&gt;: See my May 2023 post &lt;a href="https://ccoff.github.io/chasing-weather-satellites-sequel"&gt;"Chasing weather satellites: the sequel"&lt;/a&gt; for further adventures with weather satellites.]&lt;/p&gt;</content><category term="radio"></category><category term="sdr"></category><category term="satellites"></category></entry><entry><title>Customizing a live ISO image</title><link href="https://ccoff.github.io/customizing-live-iso-image" rel="alternate"></link><published>2020-04-26T00:00:00+01:00</published><updated>2020-04-26T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2020-04-26:/customizing-live-iso-image</id><summary type="html">&lt;p&gt;I have an &lt;a href="https://www.digital-loggers.com/api_faqs.html"&gt;Atomic Pi&lt;/a&gt; that I use as a NAS. Every now and then, I back up the on-board eMMC with &lt;em&gt;dd&lt;/em&gt;. To do this, I boot from a &lt;a href="https://www.debian.org/CD/live"&gt;live Debian image&lt;/a&gt; on a USB stick. This requires attaching a keyboard and monitor to the normally headless server, though …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have an &lt;a href="https://www.digital-loggers.com/api_faqs.html"&gt;Atomic Pi&lt;/a&gt; that I use as a NAS. Every now and then, I back up the on-board eMMC with &lt;em&gt;dd&lt;/em&gt;. To do this, I boot from a &lt;a href="https://www.debian.org/CD/live"&gt;live Debian image&lt;/a&gt; on a USB stick. This requires attaching a keyboard and monitor to the normally headless server, though -- the live image waits for a keypress at the boot menu, and it doesn't start an SSH server. So there is no way to access it remotely.&lt;/p&gt;
&lt;p&gt;I wanted to be able to plug in the live USB stick, boot the server, connect via SSH, and &lt;em&gt;dd&lt;/em&gt; the eMMC without having to connect other hardware. As it turns out, modifying the filesystem of a live ISO image is not difficult. The following procedure shows how to take a Debian live ISO file, unpack it, modify the filesystem, and pack it back up into a new, customized ISO file.&lt;/p&gt;
&lt;p&gt;First, we create some working directories where we can extract and modify the ISO image:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mkdir -p custom-iso/mnt
mkdir -p custom-iso/iso
mkdir -p custom-iso/squashfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, we mount the Debian ISO image file to get to the files inside. (Below, it's mounted at &lt;em&gt;/media/d-live 10.4.0 st amd64&lt;/em&gt;.) We use &lt;em&gt;rsync&lt;/em&gt; to copy the files from there into the &lt;em&gt;custom-iso/iso&lt;/em&gt; directory. After that, we mount the ISO file's squashfs filesystem in the &lt;em&gt;custom-iso/mnt&lt;/em&gt; directory, and finally copy the unpacked contents of the squashed filesystem into the &lt;em&gt;custom-iso/squashfs&lt;/em&gt; directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cd custom-iso
sudo rsync -a /media/d-live\ 10.4.0\ st\ amd64/ iso/
sudo mount -o loop iso/live/filesystem.squashfs mnt
sudo rsync -a mnt/ squashfs/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We have the squash filesystem extracted, and we're ready to modify it. Before we enter a chroot to do that though, let's copy the current &lt;em&gt;resolv.conf&lt;/em&gt; to make sure networking works correctly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo cp /etc/resolv.conf squashfs/etc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we can enter the chroot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo chroot ./squashfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We can make any changes we like in here. The following commands install an SSH server, configure it, and clean up. Remember, this is all done &lt;em&gt;inside&lt;/em&gt; the chroot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mount -t proc none /proc/
mount -t sysfs none /sys/

apt update
apt install openssh-server

# Set a root password:
passwd

# Add a regular user for SSH logins:
sudo adduser sshuser

# Configure sshd_config, make any other configuration changes here, etc.

# Clean up after ourselves:
apt clean
rm -rf /tmp/*
umount /proc/
umount /sys/
 rm ~/.bash_history
 exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(Note the leading space before the last two commands -- this ensures Bash doesn't save the commands in its history.)&lt;/p&gt;
&lt;p&gt;At this point, we've modified the filesystem to what we want, but we still need to make a few more tweaks to the live configuration. The default Debian live ISO waits for the user to select an option during startup -- obviously that's a problem in a headless environment. We want the image to boot automatically with no intervention so we can get the all-important SSH server running. So we edit the &lt;em&gt;iso/boot/grub/grub.cfg&lt;/em&gt; file, and set a timeout (2 seconds here) for the boot menu:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;set timeout=2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We want to cover EFI and isolinux boot environments, so we edit the &lt;em&gt;iso/isolinux/isolinux.cfg&lt;/em&gt; file as well (here the time is specified in deciseconds):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;timeout 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That's it for the modifications. Now we're ready to build a new ISO file with our changes in it. First we need to install a few packages:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt install xorriso
sudo apt install isolinux
sudo apt install squashfs-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next we "re-squash" the filesystem and copy it back into the &lt;em&gt;iso/live&lt;/em&gt; directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo mksquashfs squashfs filesystem.squashfs
cp filesystem.squashfs iso/live
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And finally, we build the new ISO file with the following lovely one-liner... We can change the &lt;strong&gt;-outdev&lt;/strong&gt; and &lt;strong&gt;-volid&lt;/strong&gt; options to whatever names we want for the filename and volume name:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xorriso -outdev debian-live-10.4.0-amd64-custom.iso -volid d-live\ 10.4\ cust\ amd64 -padding 0 \
-compliance no_emul_toc -map ./iso / -chmod 0755 / -- -boot_image isolinux dir=/isolinux \
-boot_image isolinux system_area=/usr/lib/ISOLINUX/isohdpfx.bin -boot_image any next \
-boot_image any efi_path=boot/grub/efi.img -boot_image isolinux partition_entry=gpt_basdat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When that command finishes, we have a customized ISO file suitable for a USB drive, CD, or other boot media. And making disk image backups on a headless device is much easier now.&lt;/p&gt;</content><category term="linux"></category><category term="iso"></category><category term="live image"></category></entry><entry><title>The art of finding a UART</title><link href="https://ccoff.github.io/art-of-finding-uart" rel="alternate"></link><published>2020-01-21T00:00:00+00:00</published><updated>2020-01-21T00:00:00+00:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2020-01-21:/art-of-finding-uart</id><summary type="html">&lt;p&gt;Recently I had access to an &lt;a href="https://www.meetibi.com"&gt;Ibi&lt;/a&gt; to play around with. The Ibi is a networked media storage device from Sandisk, which is now part of Western Digital. Sandisk bills the Ibi as a "personal cloud for your photos and videos." However, you can only use it with their Ibi …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I had access to an &lt;a href="https://www.meetibi.com"&gt;Ibi&lt;/a&gt; to play around with. The Ibi is a networked media storage device from Sandisk, which is now part of Western Digital. Sandisk bills the Ibi as a "personal cloud for your photos and videos." However, you can only use it with their Ibi smartphone app, and that app requires a ridiculous amount of permissions -- you might as well install a backdoor on your phone. I wanted to see what made the Ibi tick, and if it could be customized.&lt;/p&gt;
&lt;p&gt;On the outside, the Ibi has a USB 3.0 port, power jack, and LED. There is no ethernet port, only WiFi, and no video output. Beyond that it's a black box (figuratively speaking, as it has a white case). What I needed was a serial &lt;a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter"&gt;UART&lt;/a&gt; (universal asynchronous receiver-transmitter) connection to see device startup messages and information about its configuration. Many routers, switches, and other embedded devices have some sort of UART capability for troubleshooting and diagnostic purposes, and I hoped the Ibi would be the same.&lt;/p&gt;
&lt;p&gt;I opened up the case, and the Ibi's innards slid out easily enough. There was a main &lt;a href="https://en.wikipedia.org/wiki/Printed_circuit_board"&gt;PCB&lt;/a&gt; with the hard drive underneath:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/ibi-main-pcb.jpg"&gt;&lt;img src="images/ibi-main-pcb.jpg" alt="Image: Ibi main PCB" width="480" /&gt;&lt;/a&gt;
&lt;figcaption&gt;That 4-pin header (circled) looks interesting...&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Of most interest was the 4-pin header at J1 (circled in the image above), which I suspected was a UART. With the Ibi powered off, I used a multimeter to test J1's pins for ground, which turned out to be pin 4. Pins 2 and 3 had thin traces on the back of the PCB running towards the &lt;a href="https://en.wikipedia.org/wiki/System_on_a_chip"&gt;SoC&lt;/a&gt; (see arrows in the image below). These were quite likely the transmit (TX) and receive (RX) pins: &lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/ibi-uart-traces.jpg"&gt;&lt;img src="images/ibi-uart-traces.jpg" alt="Image: J1 header, pins 2 and 3 traces" width="480" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;So pin 1 remained as the likely candidate for power (VCC). I powered up the device several times, measuring the voltage on pins 1, 2, and 3. Pins 1 and 3 remained steady at 3.3V, but the voltage on pin 2 fluctuated during startup. This was probably the TX pin shoveling out serial data.&lt;/p&gt;
&lt;p&gt;Based on all of this information, at this point I was pretty confident that pin 1 = VCC, pin 2 = TX, pin 3 = RX, and 4 = GND. Before I hooked up my USB-UART adapter though, I used a logic analyzer to confirm my hypothesis. The analyzer's parser showed that there was indeed outgoing data that it could decode on pin 2:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/ibi-saleae-capture.png"&gt;&lt;img src="images/ibi-saleae-capture.png" alt="Image: Saleae Logic Analyzer serial parser capture" width="641" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Next, I connected the USB-UART adapter and started &lt;em&gt;screen&lt;/em&gt; at the standard 115200 baud rate:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;screen /dev/ttyUSB0 115200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I powered up the board, and was greeted with a stream of text as U-Boot and the kernel did their thing:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[sid]delta long!!11250

[sid]delta long!!11250

C1:80000000
C2
?
C3h
hwsetting size: 000005EC
C4
f 
5-5
Goto FSBL: 0x10100000

[*** Output truncated for brevity ***]

CPU  : Cortex-A53 quad core - AARCH32
Board: Realtek QA Board
DRAM:  1 GiB
Watchdog: Disabled
Cache: Enabled
Non-Cache Region: 1 MB@0x07900000
nor flash id [0x00ef4014]
sector 256k en: 0
sector  64k en: 1
sector  32k en: 1
sector   4k en: 1
page_program  : 1
max capacity  : 0x00100000
spi type name : WINBOND_W25Q80BV_8Mbit
[SATA] enable SATA interface
[SATA] spread-spectrum disable
Factory: NOR
Factory: pp:0, seq#:0x10, size:0x2800

[*** Output truncated for brevity ***]

[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Initializing cgroup subsys cpuacct
[    0.000000] Linux version 4.1.17 (build@build-yocto2) (gcc version 4.9.4 20150629 (prerelease) (Realtek ASDK64-4.9.4p1 Build 2285) ) #1 SMP PREEMPT Wed Jul 24 17:13:01 PDT 2019 (commit id:a61c128eddbd2d423fca8adfe4ee1c2aaa8ee6df)
[    0.000000] CPU: AArch64 Processor [410fd034] revision 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After startup completed, I arrived at a shell prompt as the root user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;root@yodaplus32_mini:/ #
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So the UART gave me what I needed -- visibility into the startup process, and a shell for looking around the filesystem. It turns out the Ibi uses a two-stage U-Boot loading process and runs Android. There is no SSH server (or even a text editor) installed, so it's a pretty bare-bones OS installation.&lt;/p&gt;
&lt;p&gt;The bootup process indicates the CPU is a quad-core A53 ARM processor; looking at the board under the heatsink reveals a &lt;a href="https://www.realtek.com/en/products/communications-network-ics/item/rtd1295"&gt;Realtek RTD1295 SoC&lt;/a&gt;. Unfortunately, Linux kernel support for the Realtek RTD1295 is patchy, though work appears to be picking up in that area. Hopefully in the near future, it will be possible to boot a vanilla kernel on the Ibi and get a full Linux distro running on it, as opposed to a locked-down Android install.&lt;/p&gt;</content><category term="hardware"></category><category term="reverse engineer"></category><category term="UART"></category></entry><entry><title>Repairing an LCD monitor</title><link href="https://ccoff.github.io/repairing-lcd-monitor" rel="alternate"></link><published>2019-12-14T00:00:00+00:00</published><updated>2019-12-14T00:00:00+00:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2019-12-14:/repairing-lcd-monitor</id><summary type="html">&lt;p&gt;I have an old &lt;a href="https://www.dell.com/support/home/us/en/19/product-support/product/dell-e2014h/docs"&gt;Dell E2014H 20" monitor&lt;/a&gt; that recently started having issues: when I turned it on, the power LED blinked on and off over and over, and the screen remained blank. So the monitor was getting power, but something was amiss somewhere.&lt;/p&gt;
&lt;p&gt;Web searching indicated that &lt;a href="https://superuser.com/questions/729741/dell-u2311h-monitor-gone-bad-which-capacitors-do-i-replace"&gt;certain Dell …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have an old &lt;a href="https://www.dell.com/support/home/us/en/19/product-support/product/dell-e2014h/docs"&gt;Dell E2014H 20" monitor&lt;/a&gt; that recently started having issues: when I turned it on, the power LED blinked on and off over and over, and the screen remained blank. So the monitor was getting power, but something was amiss somewhere.&lt;/p&gt;
&lt;p&gt;Web searching indicated that &lt;a href="https://superuser.com/questions/729741/dell-u2311h-monitor-gone-bad-which-capacitors-do-i-replace"&gt;certain Dell monitors were prone to blown capacitors&lt;/a&gt;, which can lead to the symptoms I was seeing. In some cases, people had been able to replace the capacitors on the power supply board and restore the monitor to normal working order.&lt;/p&gt;
&lt;p&gt;I had nothing to lose and figured it was worth a shot. The first step was to disassemble the monitor, which was the hardest part by far of the entire process. Specifically, prying the bezel from the front of the monitor took some doing -- an old &lt;a href="https://en.wikipedia.org/wiki/Oyster_card"&gt;London transit card&lt;/a&gt; I had laying around proved to be the best tool for this. In any event, after some careful disassembly at last I had unrestricted access to the power supply board:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/monitor-power-supply-board.jpg"&gt;&lt;img src="images/monitor-power-supply-board.jpg" alt="Image: Power supply board" width="480" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;Sure enough, there were three blown capacitors exhibiting the telltale bulging "dome" top and residue:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/monitor-power-supply-board-closeup.jpg"&gt;&lt;img src="images/monitor-power-supply-board-closeup.jpg" alt="Image: Power supply board closeup" width="480" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;I figured I might as well replace all of the power supply capacitors while I had the monitor disassembled. There were four different types of capacitors on the power supply board:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;470 mF, 16 V (these were the three blown caps)&lt;/li&gt;
&lt;li&gt;470 mF, 25 V&lt;/li&gt;
&lt;li&gt;47 mF, 50 V&lt;/li&gt;
&lt;li&gt;4.7 mF, 100 V&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, the capacitors needed to have low &lt;a href="https://en.wikipedia.org/wiki/Equivalent_series_resistance"&gt;ESR&lt;/a&gt;, high &lt;a href="https://en.wikipedia.org/wiki/Ripple_(electrical)"&gt;ripple current&lt;/a&gt;, and be rated for high temperature.&lt;/p&gt;
&lt;p&gt;I was able to find them all with the exception of the 4.7 mF, 100 V which despite my best efforts I could not locate anywhere. Still, for less than $10 US I had high-quality Panasonic capacitors (from &lt;a href="https://www.mouser.com"&gt;mouser.com&lt;/a&gt;) that I could use to replace all of the existing capacitors except the elusive 4.7 mF, 100 V.&lt;/p&gt;
&lt;p&gt;I removed the old capacitors and soldered the new ones on the power supply board. I then reassembled the monitor, and the moment of truth arrived. I plugged in the power cord and - boom! - it powered up without a hitch:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/monitor-working.jpg"&gt;&lt;img src="images/monitor-working.jpg" alt="Image: Monitor working" width="600" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Success!&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;So with less than $10 of parts I was able to reclaim a monitor otherwise destined to become e-waste.&lt;/p&gt;</content><category term="hardware"></category><category term="repair"></category><category term="monitor"></category></entry><entry><title>Preserving IMAP keywords during e-mail migrations</title><link href="https://ccoff.github.io/preserving-imap-keywords" rel="alternate"></link><published>2018-08-27T00:00:00+01:00</published><updated>2018-08-27T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2018-08-27:/preserving-imap-keywords</id><summary type="html">&lt;p&gt;Recently I had to migrate several e-mail accounts from one server to another. Some of the accounts were quite large; one had over 20,000 messages in it. I tried a few IMAP migration tools, but they all had some issue or another -- one would hang after a few thousand …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I had to migrate several e-mail accounts from one server to another. Some of the accounts were quite large; one had over 20,000 messages in it. I tried a few IMAP migration tools, but they all had some issue or another -- one would hang after a few thousand messages, while another one skipped messages here and there, seemingly at random.&lt;/p&gt;
&lt;p&gt;Searching GitHub, I came across &lt;a href="https://github.com/wrzlbrmft/imapcopy"&gt;Imapcopy&lt;/a&gt;, a PHP-based IMAP migration script that didn't have a lot of extra bells and whistles. It appeared to just "do one thing and do it well" -- get all of the messages from one server to the other. In my testing, it worked well in almost every way; it was stable, fast, and didn't skip any messages. Unfortunately, however, it didn't preserve IMAP keywords.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAP keywords&lt;/strong&gt;, also known as &lt;strong&gt;custom flags&lt;/strong&gt; or &lt;strong&gt;tags&lt;/strong&gt;, are user-defined labels that you can assign to messages. Messages can have more than one keyword associated with them, allowing for multi-dimensional sorting. For example, you could define "Personal", "Family", and "Friends" keywords, and assign them interchangeably to messages and sort accordingly. Additionally, many e-mail clients use some sort of visual indicator (e.g., color) to differentiate messages by keyword, allowing you to rapidly scan an inbox and see what types of messages it contains.&lt;/p&gt;
&lt;p&gt;My primary e-mail client, &lt;a href="https://www.thunderbird.net"&gt;Thunderbird&lt;/a&gt;, uses these keywords extensively, both for arbitrary user-defined tags and for core functionality. For example, forwarded messages contain the &lt;a href="https://tools.ietf.org/html/rfc5788#section-3.4.2"&gt;"$Forwarded"&lt;/a&gt; keyword, which Thunderbird uses to display a special icon next to the message. I use several custom keywords to organize messages in my inboxes, and I absolutely had to have these preserved with the messages.&lt;/p&gt;
&lt;p&gt;So I looked at adding IMAP keyword preservation to Imapcopy. It had been awhile since I had worked with PHP, and I quickly discovered the built-in PHP IMAP e-mail functions were a bit lacking -- there was no function to directly fetch message keywords. However, you can obtain the raw IMAP message headers with the &lt;a href="https://secure.php.net/manual/en/function.imap-headers.php"&gt;&lt;strong&gt;imap_headers()&lt;/strong&gt;&lt;/a&gt; function. Here is a sample IMAP header as returned by &lt;strong&gt;imap_headers()&lt;/strong&gt;: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  A    30)28-Jun-2018 Postmaster           {NonJunk $Forwarded} Registration renewal (3245 chars)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The keywords always start at position 44 in the header, and are enclosed in braces {}. From that we can manually parse the header and obtain the keywords.&lt;/p&gt;
&lt;p&gt;From there, it was a simple matter of adding the parsed keywords to the migrated message's header. I tested everything thoroughly (the last thing we want is a corrupted mailbox!) and everything migrated over correctly. A merged &lt;a href="https://github.com/wrzlbrmft/imapcopy/pull/7"&gt;pull request&lt;/a&gt; later, and Imapcopy now does everything I want it to do, quickly and easily creating a perfect (as near as I can tell) duplicate of the source message and its attributes on the destination server with minimal fuss.&lt;/p&gt;</content><category term="imap"></category><category term="e-mail"></category><category term="php"></category></entry><entry><title>A modest mouse: Building a low-cost, head-mounted infrared pointing device</title><link href="https://ccoff.github.io/a-modest-mouse" rel="alternate"></link><published>2018-05-30T00:00:00+01:00</published><updated>2018-05-30T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2018-05-30:/a-modest-mouse</id><summary type="html">&lt;p&gt;I stopped using a mouse a few years ago and replaced it with a small USB touchpad. Still, I've always had an eye on getting rid of hand-based pointing devices completely. A few months back, I saw &lt;a href="https://arstechnica.com/gaming/2018/02/coding-without-a-keystroke-the-hands-free-creation-of-a-full-video-game"&gt;an article on Ars Technica&lt;/a&gt; about a coder who programmed a game entirely …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I stopped using a mouse a few years ago and replaced it with a small USB touchpad. Still, I've always had an eye on getting rid of hand-based pointing devices completely. A few months back, I saw &lt;a href="https://arstechnica.com/gaming/2018/02/coding-without-a-keystroke-the-hands-free-creation-of-a-full-video-game"&gt;an article on Ars Technica&lt;/a&gt; about a coder who programmed a game entirely without using his hands. He primarily used speech recognition, but for a mouse replacement, he used a &lt;a href="https://www.naturalpoint.com/smartnav/products/4-at"&gt;SmartNav 4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The SmartNav 4 uses an infrared (IR) transmitter, reflector, and sensor to track a user's head movements and move the mouse pointer accordingly. Essentially a combined transmitter/receiver unit sits by the monitor. It sends out an IR beam that is sent back to the sensor by a special reflective sticker affixed to the user's head (either directly, or on a hat).&lt;/p&gt;
&lt;p&gt;Unfortunately, the SmartNav costs $500 US -- not exactly an inexpensive piece of hardware! And SmartNav is one of the 'cheaper' options; you can easily pay $1500 US for similar products.&lt;/p&gt;
&lt;p&gt;It got me thinking about building a head-based IR pointing device on the cheap. I considered a design similar to the SmartNav, but I wasn't excited about shining IR LEDs into my eyes for long periods of time. Supposedly the SmartNav has filters to handle this, but I didn't want to take the risk with my own setup. So instead of the transmitter beaming IR towards the head (as the SmartNav does), my head would be the 'platform' for the IR transmitter, and the computer would be the IR receiver.&lt;/p&gt;
&lt;h2&gt;Hardware&lt;/h2&gt;
&lt;p&gt;First I needed something that could detect IR on the computer's side. I had a cheap webcam lying around:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-cheap-webcam.jpg"&gt;&lt;img src="images/mouse-cheap-webcam.jpg" alt="Image: Cheap webcam" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;I did the tried-and-true test of pressing a button on a TV remote and looking at the resultant image captured by the webcam:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-webcam-ir-test.jpg"&gt;&lt;img src="images/mouse-webcam-ir-test.jpg" alt="Image: Webcam 'seeing' infrared" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;No problem there: the camera could 'see' in infrared. In fact every webcam I tested (four in total) detected IR. &lt;/p&gt;
&lt;p&gt;Next up was the IR transmitter. It needed to be head-mounted, and comfortable. A modifiable headlamp seemed the way to go. As a proof-of-concept first though, I put together a dead-simple, battery-powered IR LED 'transmitter' on a breadboard:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-breadboard-proof-of-concept.jpg"&gt;&lt;img src="images/mouse-breadboard-proof-of-concept.jpg" alt="Image: Breadboard proof of concept" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;The webcam detected it easily, and basic software tracking using &lt;a href="https://www.opencv.org"&gt;OpenCV&lt;/a&gt; looked promising (more on this below). Stray IR and light from windows, overhead lighting, and other sources was a problem though. I needed a pass filter for IR wavelengths that I could put over the webcam lens, and &lt;a href="https://www.aliexpress.com/item/9mm-Filter-Lens-Filtering-against-400nm-750nm-Pass-808nm-1064nm-IR-InfraRed-Laser-Only/32278589551.html"&gt;this 808nm-1064nm wavelength IR pass filter&lt;/a&gt; seemed the perfect size at 9mm diameter:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-ir-pass-filter.jpg"&gt;&lt;img src="images/mouse-ir-pass-filter.jpg" alt="Image: IR pass filter" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;And here is the filter covering the webcam lens:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-cheap-webcam-with-ir-filter.jpg"&gt;&lt;img src="images/mouse-cheap-webcam-with-ir-filter.jpg" alt="Image: Webcam with IR filter in place" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;The filter dramatically reduced unwanted light from reaching the camera. I could now reliably detect and track the IR transmitter beam in various conditions: sunlight coming through open curtains, overhead lights on, etc.&lt;/p&gt;
&lt;p&gt;It was time to spend some money on a 'real' IR transmitter. I needed a headlamp with LEDs that I could modify, and &lt;a href="https://www.amazon.com/Headlamp-Headlight-Battery-Batteries-Included/dp/B005FEGYJC"&gt;this one on Amazon&lt;/a&gt; seemed to fit the bill. &lt;/p&gt;
&lt;p&gt;Disassembling the lamp was easy: twist the lens cap, remove a holding bracket, and unscrew the circuit board containing the LEDs:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/mouse-headlamp-disassembly-1.jpg"&gt;&lt;img src="images/mouse-headlamp-disassembly-1.jpg" alt="Image: Headlamp with lens cap removed" width="320" height="240" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Headlamp with lens cap removed.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/mouse-headlamp-disassembly-2.jpg"&gt;&lt;img src="images/mouse-headlamp-disassembly-2.jpg" alt="Image: Headlamp with circuit board removed" width="320" height="240" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Headlamp with circuit board removed.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/mouse-headlamp-disassembly-3.jpg"&gt;&lt;img src="images/mouse-headlamp-disassembly-3.jpg" alt="Image: Headlamp with back side of circuit board exposed" width="320" height="240" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Headlamp with back side of circuit board exposed.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;
&lt;a href="images/mouse-headlamp-disassembly-4.jpg"&gt;&lt;img src="images/mouse-headlamp-disassembly-4.jpg" alt="Image: Headlamp with side view of circuit board" width="320" height="240" /&gt;&lt;/a&gt;
&lt;figcaption&gt;Headlamp with side view of circuit board.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The lamp has four lighting modes: three levels of white light brightness (2 LEDs, 10 LEDs, and 18 LEDs), and a red light flashing mode. I de-soldered the two LEDs in the center that provide the lowest white light level, and soldered two &lt;a href="https://uk.rs-online.com/web/p/ir-leds/6997663"&gt;890nm IR LEDs&lt;/a&gt; in their place. (If you do this yourself, remember that LEDs are diodes, and the positive / negative terminals need to be soldered in the correct orientation. Look at the other LEDs on the board to determine which way they should go.)&lt;/p&gt;
&lt;p&gt;I put everything back together and tested the headlamp with the IR webcam receiver. It worked brilliantly (pun intended) -- one push of the power button turned on the IR LEDs, another push enabled medium white light, another push enabled high white light, another push enabled red flashing, and a final push turned the lamp off.&lt;/p&gt;
&lt;p&gt;I now had a functioning head-mounted IR transmitter that still worked as a "normal" headlamp if necessary.&lt;/p&gt;
&lt;h3&gt;Parts list&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Headlamp-Headlight-Battery-Batteries-Included/dp/B005FEGYJC"&gt;Headlamp&lt;/a&gt; (here is a &lt;a href="https://www.amazon.co.uk/Lighting-EVER-3200001-LED-Headlamp/dp/B005FEGYJC"&gt;UK variant&lt;/a&gt;): $8 US / £6 UK&lt;/li&gt;
&lt;li&gt;&lt;a href="https://uk.rs-online.com/web/p/ir-leds/6997663"&gt;890nm IR LEDs&lt;/a&gt;: $4.75 US / £3.40 UK for a pack of 10 (though we only need two of them for the headlamp)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.aliexpress.com/item/9mm-Filter-Lens-Filtering-against-400nm-750nm-Pass-808nm-1064nm-IR-InfraRed-Laser-Only/32278589551.html"&gt;IR pass filter&lt;/a&gt;: $4.75 US / £3.40 UK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So for less than $20 US (not counting a soldering iron or webcam) we have all the parts we need to create a head-mounted pointing device and receiver. &lt;/p&gt;
&lt;p&gt;Remember though, like the SmartNav and other related devices, this is solely a &lt;strong&gt;pointing&lt;/strong&gt; device: all it does is move the mouse pointer. It doesn't do mouse button clicks. For clicking, you need something else: a speech recognition application, a foot pedal, a USB button... there are many possibilities.&lt;/p&gt;
&lt;h2&gt;Software&lt;/h2&gt;
&lt;p&gt;(To view the code, see the &lt;a href="https://github.com/ccoff/ir-mouse"&gt;GitHub repository&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;With the hardware components ready, it was time to turn to the equally important task of writing some code to track the IR beam and move the mouse pointer.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.opencv.org"&gt;OpenCV&lt;/a&gt; is ideally suited to this task; i.e., determining where a particular type of object is located in an image. With built-in routines for webcam image captures and processing, it really takes a lot of the hard work off of your hands, allowing you to concentrate on tracking that IR beam.&lt;/p&gt;
&lt;p&gt;For mouse pointer manipulation, I had used &lt;a href="https://github.com/PyUserInput/PyUserInput"&gt;PyUserInput&lt;/a&gt; in another project of mine, and it had worked well. PyUserInput is Python-based, and OpenCV has Python bindings available. (I use Debian, and it includes the python-opencv package; your Linux distribution probably does as well. I have not tested this on Windows.)&lt;/p&gt;
&lt;p&gt;I had concerns that performance might be unacceptably slow using Python with OpenCV, but they proved to be unfounded. The app hums along with no noticeable lag between head movement and mouse pointer movement.&lt;/p&gt;
&lt;p&gt;Again, see &lt;a href="https://github.com/ccoff/ir-mouse"&gt;the code&lt;/a&gt; for details as to what is going on under the hood, but in short, it uses value and hue thresholds to filter out everything in the captured image but the IR beam. (The IR pass filter on the webcam makes this process much more reliable by removing stray interference.) If the beam has moved a sufficient distance, we move the mouse pointer as well. The greater the distance the IR pointer moves, the greater the scale factor we use to determine how much the mouse pointer moves.&lt;/p&gt;
&lt;p&gt;It took some fiddling to achieve an acceptable acceleration rate for the pointer, as well as handle small, fine movements. If you use this code in your own project, you will likely want to adjust these values (as well as the hue and value thresholds) for your own environment.&lt;/p&gt;
&lt;h2&gt;Final thoughts&lt;/h2&gt;
&lt;p&gt;So now that I have this setup, have I ditched the touchpad? No, not completely. You have to wear a headlamp on your head, which can get cumbersome. A logical next step would be to try and remove the headlamp / IR pass filter from the mix completely, and just detect head or eye movement directly, perhaps by using &lt;a href="https://docs.opencv.org/2.4/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html"&gt;OpenCV's CascadeClassifiers&lt;/a&gt;. (Hacking a headlamp is a lot more fun though!)&lt;/p&gt;
&lt;p&gt;In any event, I hope this project helps and inspires others who are looking for a low-cost, assistive technology pointing device.&lt;/p&gt;</content><category term="accessibility"></category><category term="hci"></category><category term="opencv"></category><category term="python"></category></entry><entry><title>Decoding temperature sensor data using software-defined radio</title><link href="https://ccoff.github.io/temperature-sensor-sdr-radio" rel="alternate"></link><published>2017-12-16T00:00:00+00:00</published><updated>2017-12-16T00:00:00+00:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2017-12-16:/temperature-sensor-sdr-radio</id><summary type="html">&lt;p&gt;I have an old Philips clock radio that includes a standalone temperature sensor module:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/temp-sdr-philips-bottom.jpg"&gt;&lt;img src="images/temp-sdr-philips-bottom.jpg" alt="Image: Philips outdoor temperature sensor, bottom view" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;The idea is that you place this sensor outdoors, where it periodically sends temperature updates to the clock radio inside. I wanted to capture those transmissions and use the data programmatically, instead of just seeing it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have an old Philips clock radio that includes a standalone temperature sensor module:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/temp-sdr-philips-bottom.jpg"&gt;&lt;img src="images/temp-sdr-philips-bottom.jpg" alt="Image: Philips outdoor temperature sensor, bottom view" width="320" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;The idea is that you place this sensor outdoors, where it periodically sends temperature updates to the clock radio inside. I wanted to capture those transmissions and use the data programmatically, instead of just seeing it displayed on the clock radio. It occurred to me that a radio receiver ought to be able to pick up these transmissions.&lt;/p&gt;
&lt;p&gt;I have several software-defined radio (SDR) USB dongles (such as &lt;a href="https://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/"&gt;this&lt;/a&gt; and &lt;a href="https://www.aliexpress.com/item/Mini-Portable-Digital-USB-2-0-TV-Stick-DVB-T-DAB-FM-RTL2832U-R820T2-Support-SDR/32914826153.html"&gt;this&lt;/a&gt;). It's pretty amazing what you can do with these low-cost devices, which generally have a range of around 25 MHz to 1.75 GHz. Beyond the obvious radio and TV broadcasts, I've picked up aircraft (&lt;a href="https://en.wikipedia.org/wiki/ACARS"&gt;ACARS&lt;/a&gt;) transmissions, weather data, pager and GSM traffic, and more. So I thought SDR might be a good way to see what this temperature sensor was sending to the clock radio.&lt;/p&gt;
&lt;p&gt;I had no idea what frequency the temperature sensor used, but the &lt;a href="https://en.wikipedia.org/wiki/ISM_band"&gt;ISM band&lt;/a&gt; seemed like a good place to start investigating, as many consumer-grade devices transmit around 433 MHz. The excellent and popular &lt;a href="https://github.com/merbanan/rtl_433"&gt;rtl_433 project&lt;/a&gt; supports a large number of 433 MHz devices, enabling you to decode protocols and output data in a number of formats (JSON, CSV, etc.).&lt;/p&gt;
&lt;p&gt;I plugged in an SDR dongle, started up rtl_433 and waited for the temperature sensor to send one of its updates. Sure enough, rtl_433 picked it up straight away and dumped the raw data:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[00] {40} 00 14 b9 c0 18 : 00000000 00010100 10111001 11000000 00011000 
[01] {36} 01 4b 9c 01 80 : 00000001 01001011 10011100 00000001 1000
[02] {36} 01 4b 9c 01 80 : 00000001 01001011 10011100 00000001 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The data packet was 36 bits long and repeated three times (with an extra starting nibble -- probably a sync signal of some sort -- on the first data row). rtl_433 couldn't decode anything from the data, which wasn't too surprising -- there are many, many types of sensors out there, each with their own proprietary format. If I wanted to make use of my sensor, I would have to reverse-engineer the protocol and write a decoder myself.&lt;/p&gt;
&lt;h2&gt;Reverse-engineering the protocol&lt;/h2&gt;
&lt;p&gt;First I had to determine the signal's timings. I loaded up a captured signal in Audacity:&lt;/p&gt;
&lt;figure&gt;
&lt;a href="images/temp-sdr-audacity-sample.png"&gt;&lt;img src="images/temp-sdr-audacity-sample.png" alt="Image: Sample loaded in Audacity" width="640" /&gt;&lt;/a&gt;
&lt;/figure&gt;

&lt;p&gt;This showed a good, strong signal, with the long and short pulses clearly visible; the temperature sensor was using &lt;a href="https://en.wikipedia.org/wiki/Pulse-width_modulation"&gt;pulse-width modulation (PWM)&lt;/a&gt;. With Audacity's selection tools, I could precisely determine the timings for the pulse and gap widths.&lt;/p&gt;
&lt;p&gt;With that done, I could work on the protocol data itself. I knew the temperature sensor reported at least the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;Temperature (in Celsius)&lt;/li&gt;
&lt;li&gt;Battery status&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By manually changing the sensor's channel, placing it in the freezer, using an old battery, etc. I could see where and how the data packets changed. From there it was a relatively straightforward process to map out the protocol.&lt;/p&gt;
&lt;p&gt;One final piece remained -- the last nibble in the packet changed based on the preceding data. I assumed it was a checksum or CRC of some sort. Basic checksum tests turned up nothing, so I turned to the excellent &lt;a href="http://reveng.sourceforge.net"&gt;RevEng&lt;/a&gt;, which can calculate a huge number of CRCs for a given bit pattern. RevEng made short work of the data and determined it was using CRC-4 with a polynomial 0x9 and initial value of 0x1.&lt;/p&gt;
&lt;h2&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;Having decoded the temperature sensor's protocol, it was easy enough to write up a decoder for it in rtl_433. A &lt;a href="https://github.com/merbanan/rtl_433/pull/619"&gt;Github PR&lt;/a&gt; later, and rtl_433 now includes support for my Philips temperature sensor (see the code &lt;a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/philips_aj3650.c"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Now I can pick off data from the temperature sensor and output it in a variety of formats for further processing. Here's some sample output, with sensor data in JSON on the last line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;walrus@box:~$ rtl_433 -F json
rtl_433 version 18.12-89-gdd842fc8af branch master at 201902131202 inputs file rtl_tcp RTL-SDR
Registered 96 out of 120 device decoding protocols [ 1-4 8 11-12 15-17 19-21 23 25-26 29-36 38-60 62-64 67-71 73-100 102-103 108-116 119 ]
Detached kernel driver
Found Rafael Micro R820T tuner
Exact sample rate is: 250000.000414 Hz
[R82XX] PLL not locked!
Sample rate set to 250000 S/s.
Tuner gain set to Auto.
Tuned to 433.920MHz.
{&amp;quot;time&amp;quot; : &amp;quot;2017-12-16 14:25:38&amp;quot;, &amp;quot;model&amp;quot; : &amp;quot;Philips outdoor temperature sensor&amp;quot;, &amp;quot;channel&amp;quot; : 3, &amp;quot;temperature_C&amp;quot; : 22.800, &amp;quot;battery&amp;quot; : &amp;quot;OK&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="radio"></category><category term="sdr"></category><category term="sensors"></category></entry></feed>