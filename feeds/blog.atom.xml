<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>0xCC0FF - blog</title><link href="https://ccoff.github.io/" rel="alternate"></link><link href="https://ccoff.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://ccoff.github.io/</id><updated>2018-05-30T00:00:00+01:00</updated><entry><title>A modest mouse: Building a low-cost, head-mounted infrared pointing device</title><link href="https://ccoff.github.io/a-modest-mouse" rel="alternate"></link><published>2018-05-30T00:00:00+01:00</published><updated>2018-05-30T00:00:00+01:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2018-05-30:/a-modest-mouse</id><summary type="html">&lt;p&gt;I stopped using a mouse a few years ago and replaced it with a small USB touchpad. Still, I've always had an eye on getting rid of hand-based pointing devices completely. A few months back, I saw &lt;a href="https://arstechnica.com/gaming/2018/02/coding-without-a-keystroke-the-hands-free-creation-of-a-full-video-game"&gt;an article on Ars Technica&lt;/a&gt; about a coder who programmed a game entirely …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I stopped using a mouse a few years ago and replaced it with a small USB touchpad. Still, I've always had an eye on getting rid of hand-based pointing devices completely. A few months back, I saw &lt;a href="https://arstechnica.com/gaming/2018/02/coding-without-a-keystroke-the-hands-free-creation-of-a-full-video-game"&gt;an article on Ars Technica&lt;/a&gt; about a coder who programmed a game entirely without using his hands. He primarily used speech recognition, but for a mouse replacement, he used a &lt;a href="https://www.naturalpoint.com/smartnav/products/4-at"&gt;SmartNav 4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The SmartNav 4 uses an infrared (IR) transmitter, reflector, and sensor to track a user's head movements and move the mouse pointer accordingly. Essentially a combined transmitter/receiver unit sits by the monitor. It sends out an IR beam that is sent back to the sensor by a special reflective sticker affixed to the user's head (either directly, or on a hat).&lt;/p&gt;
&lt;p&gt;Unfortunately, the SmartNav costs $500 US -- not exactly an inexpensive piece of hardware! And SmartNav is one of the 'cheaper' options; you can easily pay $1500 US for similar products.&lt;/p&gt;
&lt;p&gt;It got me thinking about building a head-based IR pointing device on the cheap. I considered a design similar to the SmartNav, but I wasn't excited about shining IR LEDs into my eyes for long periods of time. Supposedly the SmartNav has filters to handle this, but I didn't want to take the risk with my own setup. So instead of the transmitter beaming IR towards the head (as the SmartNav does), my head would be the 'platform' for the IR transmitter, and the computer would be the IR receiver.&lt;/p&gt;
&lt;h2&gt;Hardware&lt;/h2&gt;
&lt;p&gt;First I needed something that could detect IR on the computer's side. I had a cheap webcam lying around:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/cheap-webcam.jpg" alt="Image: Cheap webcam" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;I did the tried-and-true test of pressing a button on a TV remote and looking at the resultant image captured by the webcam:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/webcam-ir-test.jpg" alt="Image: Webcam 'seeing' infrared" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;No problem there: the camera could 'see' in infrared. In fact every webcam I tested (four in total) detected IR. &lt;/p&gt;
&lt;p&gt;Next up was the IR transmitter. It needed to be head-mounted, and comfortable. A modifiable headlamp seemed the way to go. As a proof-of-concept first though, I put together a dead-simple, battery-powered IR LED 'transmitter' on a breadboard:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/breadboard-proof-of-concept.jpg" alt="Image: Breadboard proof of concept" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;The webcam detected it easily, and basic software tracking using &lt;a href="https://www.opencv.org"&gt;OpenCV&lt;/a&gt; looked promising (more on this below). Stray IR and light from windows, overhead lighting, and other sources was a problem though. I needed a pass filter for IR wavelengths that I could put over the webcam lens, and &lt;a href="https://www.aliexpress.com/item/9mm-Filter-Lens-Filtering-against-400nm-750nm-Pass-808nm-1064nm-IR-InfraRed-Laser-Only/32278589551.html"&gt;this 808nm-1064nm wavelength IR pass filter&lt;/a&gt; seemed the perfect size at 9mm diameter:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/ir-pass-filter.jpg" alt="Image: IR pass filter" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;And here is the filter covering the webcam lens:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/cheap-webcam-with-ir-filter.jpg" alt="Image: Webcam with IR filter in place" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;The filter dramatically reduced unwanted light from reaching the camera. I could now reliably detect and track the IR transmitter beam in various conditions: sunlight coming through open curtains, overhead lights on, etc.&lt;/p&gt;
&lt;p&gt;It was time to spend some money on a 'real' IR transmitter. I needed a headlamp with LEDs that I could modify, and &lt;a href="https://www.amazon.com/Headlamp-Headlight-Battery-Batteries-Included/dp/B005FEGYJC"&gt;this one on Amazon&lt;/a&gt; seemed to fit the bill. &lt;/p&gt;
&lt;p&gt;Disassembling the lamp was easy: twist the lens cap, remove a holding bracket, and unscrew the circuit board containing the LEDs:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/headlamp-disassembly-1.jpg" alt="Image: Headlamp with lens cap removed" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="images/headlamp-disassembly-2.jpg" alt="Image: Headlamp with circuit board removed" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="images/headlamp-disassembly-3.jpg" alt="Image: Headlamp with back side of circuit board exposed" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="images/headlamp-disassembly-4.jpg" alt="Image: Headlamp with side view of circuit board" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;The lamp has four lighting modes: three levels of white light brightness (2 LEDs, 10 LEDs, and 18 LEDs), and a red light flashing mode. I de-soldered the two LEDs in the center that provide the lowest white light level, and soldered two &lt;a href="https://uk.rs-online.com/web/p/ir-leds/6997663"&gt;890nm IR LEDs&lt;/a&gt; in their place. (If you do this yourself, remember that LEDs are diodes, and the positive / negative terminals need to be soldered in the correct orientation. Look at the other LEDs on the board to determine which way they should go.)&lt;/p&gt;
&lt;p&gt;I put everything back together and tested the headlamp with the IR webcam receiver. It worked brilliantly (pun intended) -- one push of the power button turned on the IR LEDs, another push enabled medium white light, another push enabled high white light, another push enabled red flashing, and a final push turned the lamp off.&lt;/p&gt;
&lt;p&gt;I now had a functioning head-mounted IR transmitter that still worked as a "normal" headlamp if necessary.&lt;/p&gt;
&lt;h3&gt;Parts list&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Headlamp-Headlight-Battery-Batteries-Included/dp/B005FEGYJC"&gt;Headlamp&lt;/a&gt; (here is a &lt;a href="https://www.amazon.co.uk/Lighting-EVER-3200001-LED-Headlamp/dp/B005FEGYJC"&gt;UK variant&lt;/a&gt;): $8 US / £6 UK&lt;/li&gt;
&lt;li&gt;&lt;a href="https://uk.rs-online.com/web/p/ir-leds/6997663"&gt;890nm IR LEDs&lt;/a&gt;: $4.75 US / £3.40 UK for a pack of 10 (though we only need two of them for the headlamp)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.aliexpress.com/item/9mm-Filter-Lens-Filtering-against-400nm-750nm-Pass-808nm-1064nm-IR-InfraRed-Laser-Only/32278589551.html"&gt;IR pass filter&lt;/a&gt;: $4.75 US / £3.40 UK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So for less than $20 US (not counting a soldering iron or webcam) we have all the parts we need to create a head-mounted pointing device and receiver. &lt;/p&gt;
&lt;p&gt;Remember though, like the SmartNav and other related devices, this is solely a &lt;strong&gt;pointing&lt;/strong&gt; device: all it does is move the mouse pointer. It doesn't do mouse button clicks. For clicking, you need something else: a speech recognition application, a foot pedal, a USB button... there are many possibilities.&lt;/p&gt;
&lt;h2&gt;Software&lt;/h2&gt;
&lt;p&gt;(To view the code, see the &lt;a href="https://github.com/ccoff/ir-mouse"&gt;GitHub repository&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;With the hardware components ready, it was time to turn to the equally important task of writing some code to track the IR beam and move the mouse pointer.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.opencv.org"&gt;OpenCV&lt;/a&gt; is ideally suited to this task; i.e., determining where a particular type of object is located in an image. With built-in routines for webcam image captures and processing, it really takes a lot of the hard work off of your hands, allowing you to concentrate on tracking that IR beam.&lt;/p&gt;
&lt;p&gt;For mouse pointer manipulation, I had used &lt;a href="https://github.com/PyUserInput/PyUserInput"&gt;PyUserInput&lt;/a&gt; in another project of mine, and it had worked well. PyUserInput is Python-based, and OpenCV has Python bindings available. (I use Debian, and it includes the python-opencv package; your Linux distribution probably does as well. I have not tested this on Windows.)&lt;/p&gt;
&lt;p&gt;I had concerns that performance might be unacceptably slow using Python with OpenCV, but they proved to be unfounded. The app hums along with no noticeable lag between head movement and mouse pointer movement.&lt;/p&gt;
&lt;p&gt;Again, see &lt;a href="https://github.com/ccoff/ir-mouse"&gt;the code&lt;/a&gt; for details as to what is going on under the hood, but in short, it uses value and hue thresholds to filter out everything in the captured image but the IR beam. (The IR pass filter on the webcam makes this process much more reliable by removing stray interference.) If the beam has moved a sufficient distance, we move the mouse pointer as well. The greater the distance the IR pointer moves, the greater the scale factor we use to determine how much the mouse pointer moves.&lt;/p&gt;
&lt;p&gt;It took some fiddling to achieve an acceptable acceleration rate for the pointer, as well as handle small, fine movements. If you use this code in your own project, you will likely want to adjust these values (as well as the hue and value thresholds) for your own environment.&lt;/p&gt;
&lt;h2&gt;Final thoughts&lt;/h2&gt;
&lt;p&gt;So now that I have this setup, have I ditched the touchpad? No, not completely. You have to wear a headlamp on your head, which can get cumbersome. A logical next step would be to try and remove the headlamp / IR pass filter from the mix completely, and just detect head or eye movement directly, perhaps by using &lt;a href="https://docs.opencv.org/2.4/doc/tutorials/objdetect/cascade_classifier/cascade_classifier.html"&gt;OpenCV's CascadeClassifiers&lt;/a&gt;. (Hacking a headlamp is a lot more fun though!)&lt;/p&gt;
&lt;p&gt;In any event, I hope this project helps and inspires others who are looking for a low-cost, assistive technology pointing device.&lt;/p&gt;</content><category term="accessibility"></category><category term="hci"></category><category term="opencv"></category><category term="python"></category></entry><entry><title>Decoding temperature sensor data using software-defined radio</title><link href="https://ccoff.github.io/temperature-sensor-sdr-radio" rel="alternate"></link><published>2017-12-16T00:00:00+00:00</published><updated>2017-12-16T00:00:00+00:00</updated><author><name>Chris Coffey (ccoff)</name></author><id>tag:ccoff.github.io,2017-12-16:/temperature-sensor-sdr-radio</id><summary type="html">&lt;p&gt;I have an old Philips clock radio that includes a standalone temperature sensor module:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/philips_bottom.jpg" alt="Image: Philips outdoor temperature sensor" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;The idea is that you place this sensor outdoors, where it periodically sends temperature updates to the clock radio inside. I wanted to capture those transmissions and use the data programmatically, instead of just seeing it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have an old Philips clock radio that includes a standalone temperature sensor module:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/philips_bottom.jpg" alt="Image: Philips outdoor temperature sensor" width="320" height="240" /&gt;&lt;/p&gt;
&lt;p&gt;The idea is that you place this sensor outdoors, where it periodically sends temperature updates to the clock radio inside. I wanted to capture those transmissions and use the data programmatically, instead of just seeing it displayed on the clock radio. It occurred to me that a radio receiver ought to be able to pick up these transmissions.&lt;/p&gt;
&lt;p&gt;I have several software-defined radio (SDR) USB dongles (such as &lt;a href="https://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/"&gt;this&lt;/a&gt; and &lt;a href="https://www.aliexpress.com/item/Mini-Portable-Digital-USB-2-0-TV-Stick-DVB-T-DAB-FM-RTL2832U-R820T2-Support-SDR/32914826153.html"&gt;this&lt;/a&gt;). It's pretty amazing what you can do with these low-cost devices, which generally have a range of around 25 MHz to 1.75 GHz. Beyond the obvious radio and TV broadcasts, I've picked up aircraft (&lt;a href="https://en.wikipedia.org/wiki/ACARS"&gt;ACARS&lt;/a&gt;) transmissions, weather data, pager and GSM traffic, and more. So I thought SDR might be a good way to see what this temperature sensor was sending to the clock radio.&lt;/p&gt;
&lt;p&gt;I had no idea what frequency the temperature sensor used, but the &lt;a href="https://en.wikipedia.org/wiki/ISM_band"&gt;ISM band&lt;/a&gt; seemed like a good place to start investigating, as many consumer-grade devices transmit around 433 MHz. The excellent and popular &lt;a href="https://github.com/merbanan/rtl_433"&gt;rtl_433 project&lt;/a&gt; supports a large number of 433 MHz devices, enabling you to decode protocols and output data in a number of formats (JSON, CSV, etc.).&lt;/p&gt;
&lt;p&gt;I plugged in an SDR dongle, started up rtl_433 and waited for the temperature sensor to send one of its updates. Sure enough, rtl_433 picked it up straight away and dumped the raw data:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[00] {40} 00 14 b9 c0 18 : 00000000 00010100 10111001 11000000 00011000 
[01] {36} 01 4b 9c 01 80 : 00000001 01001011 10011100 00000001 1000
[02] {36} 01 4b 9c 01 80 : 00000001 01001011 10011100 00000001 1000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The data packet was 36 bits long and repeated three times (with an extra starting nibble -- probably a sync signal of some sort -- on the first data row). rtl_433 couldn't decode anything from the data, which wasn't too surprising -- there are many, many types of sensors out there, each with their own proprietary format. If I wanted to make use of my sensor, I would have to reverse-engineer the protocol and write a decoder myself.&lt;/p&gt;
&lt;h2&gt;Reverse-engineering the protocol&lt;/h2&gt;
&lt;p&gt;First I had to determine the signal's timings. I loaded up a captured signal in Audacity:&lt;/p&gt;
&lt;p&gt;&lt;img src="images/audacity-sample.png" alt="Image: Sample loaded in Audacity" width="640" height="270" /&gt;&lt;/p&gt;
&lt;p&gt;This showed a good, strong signal, with the long and short pulses clearly visible; the temperature sensor was using &lt;a href="https://en.wikipedia.org/wiki/Pulse-width_modulation"&gt;pulse-width modulation (PWM)&lt;/a&gt;. With Audacity's selection tools, I could precisely determine the timings for the pulse and gap widths.&lt;/p&gt;
&lt;p&gt;With that done, I could work on the protocol data itself. I knew the temperature sensor reported at least the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;Temperature (in Celsius)&lt;/li&gt;
&lt;li&gt;Battery status&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By manually changing the sensor's channel, placing it in the freezer, using an old battery, etc. I could see where and how the data packets changed. From there it was a relatively straightforward process to map out the protocol.&lt;/p&gt;
&lt;p&gt;One final piece remained -- the last nibble in the packet changed based on the preceding data. I assumed it was a checksum or CRC of some sort. Basic checksum tests turned up nothing, so I turned to the excellent &lt;a href="http://reveng.sourceforge.net"&gt;RevEng&lt;/a&gt;, which can calculate a huge number of CRCs for a given bit pattern. RevEng made short work of the data and determined it was using CRC-4 with a polynomial 0x9 and initial value of 0x1.&lt;/p&gt;
&lt;h2&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;Having decoded the temperature sensor's protocol, it was easy enough to write up a decoder for it in rtl_433. A &lt;a href="https://github.com/merbanan/rtl_433/pull/619"&gt;Github PR&lt;/a&gt; later, and rtl_433 now includes support for my Philips temperature sensor (see the code &lt;a href="https://github.com/merbanan/rtl_433/blob/master/src/devices/philips.c"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Now I can pick off data from the temperature sensor and output it in a variety of formats for further processing. Here's some sample output, with sensor data in JSON on the last line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;walrus@box:~$ rtl_433 -F json
rtl_433 version 18.12-89-gdd842fc8af branch master at 201902131202 inputs file rtl_tcp RTL-SDR
Registered 96 out of 120 device decoding protocols [ 1-4 8 11-12 15-17 19-21 23 25-26 29-36 38-60 62-64 67-71 73-100 102-103 108-116 119 ]
Detached kernel driver
Found Rafael Micro R820T tuner
Exact sample rate is: 250000.000414 Hz
[R82XX] PLL not locked!
Sample rate set to 250000 S/s.
Tuner gain set to Auto.
Tuned to 433.920MHz.
{&amp;quot;time&amp;quot; : &amp;quot;2017-12-16 14:25:38&amp;quot;, &amp;quot;model&amp;quot; : &amp;quot;Philips outdoor temperature sensor&amp;quot;, &amp;quot;channel&amp;quot; : 3, &amp;quot;temperature_C&amp;quot; : 22.800, &amp;quot;battery&amp;quot; : &amp;quot;OK&amp;quot;}
&lt;/pre&gt;&lt;/div&gt;</content><category term="radio"></category><category term="sdr"></category><category term="sensors"></category></entry></feed>